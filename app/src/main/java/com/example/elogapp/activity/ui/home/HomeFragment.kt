package com.example.elogapp.activity.ui.homeimport android.app.Activityimport android.content.*import android.content.res.Configurationimport android.os.*import android.util.Logimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.view.WindowManagerimport android.view.inputmethod.InputMethodManagerimport android.webkit.JavascriptInterfaceimport android.webkit.WebViewimport android.webkit.WebViewClientimport android.widget.*import androidx.activity.OnBackPressedCallbackimport androidx.activity.result.contract.ActivityResultContractimport androidx.annotation.RequiresApiimport androidx.core.content.ContextCompatimport androidx.core.text.isDigitsOnlyimport androidx.fragment.app.Fragmentimport androidx.lifecycle.*import androidx.lifecycle.Observerimport androidx.localbroadcastmanager.content.LocalBroadcastManagerimport androidx.navigation.fragment.NavHostFragmentimport androidx.work.*import com.afollestad.materialdialogs.MaterialDialogimport com.example.devicemanager.*import com.example.devicemanager.TrackerService.TrackerBinderimport com.example.elogapp.Rimport com.example.elogapp.activity.MainActivityimport com.example.elogapp.activity.ui.recap.RecapDialogueActivityimport com.example.elogapp.database.*import com.example.elogapp.databinding.FragmentHomeBindingimport com.example.elogapp.gps.GPSTrackerimport com.example.elogapp.gps.RetrofitClientimport com.example.elogapp.repository.model.ChartInfoimport com.example.elogapp.repository.responses.BaseResponseimport com.example.elogapp.repository.responses.master.DropdownMasterResponseimport com.example.elogapp.repository.responses.master.MasterResponseimport com.example.elogapp.util.*import com.example.elogapp.util.pref.UserPreferenceimport com.google.android.material.snackbar.Snackbarimport com.google.gson.Gsonimport com.google.gson.JsonArrayimport com.google.gson.reflect.TypeTokenimport com.pt.sdk.TelemetryEventimport com.pt.sdk.request.GetStoredEventsCountimport com.pt.sdk.request.GetTrackerInfoimport com.pt.sdk.response.outbound.AckStoredEventimport com.pt.ws.VehicleInfoimport kotlinx.coroutines.*import okhttp3.Dispatcherimport okhttp3.MediaType.Companion.toMediaTypeOrNullimport okhttp3.RequestBody.Companion.toRequestBodyimport okhttp3.internal.waitimport org.json.JSONObjectimport org.kodein.di.KodeinAwareimport org.kodein.di.android.x.kodeinimport org.kodein.di.generic.instanceimport retrofit2.Callimport retrofit2.Callbackimport retrofit2.Responseimport java.text.SimpleDateFormatimport java.time.LocalDateimport java.time.LocalDateTimeimport java.time.format.DateTimeFormatterimport java.util.*import java.util.concurrent.TimeUnitimport kotlin.concurrent.timerTaskprivate var splitSleep: Int = 0private var authKey = ""lateinit var chartInfo: MutableList<ChartInfo>var myAddress: String = ""class HomeFragment : Fragment(), KodeinAware, MasterDownloadListener, View.OnClickListener,    TrackerServiceListener {    private var gpsTracker: GPSTracker? = null    override val kodein by kodein()    private val factory: HomeViewModelFactory by instance()    private lateinit var homeViewModel: HomeViewModel    private val mainScope = CoroutineScope(Dispatchers.Main)    private val exceptionHandler = CoroutineExceptionHandler { _, throwable ->        Log.e(            MainActivity::class.java.name,            "Error In: ${throwable.localizedMessage}"        )    }    private lateinit var binding: FragmentHomeBinding    private lateinit var truckNoAutoText: AutoCompleteTextView    private lateinit var coDriverAutoText: AutoCompleteTextView    private lateinit var trailerAutoText: AutoCompleteTextView    private lateinit var materResponse: MasterResponse    private lateinit var vehicleListArr: List<DropdownMaster>    private lateinit var driverListArr: List<DropdownMaster>    private lateinit var trailerListArr: List<DropdownMaster>    private var prefDutyTime: Long = 0    lateinit var on70HourTimer: CountDownTimer    lateinit var onDutyTimer: CountDownTimer    lateinit var driveTimer: CountDownTimer    lateinit var sleepTimer: CountDownTimer    var dutyTimerStarted = false    var driveTimerStarted = false    var sleepTimerStarted = false    var offDutyTimerStarted = false    var clock70HourTimerStarted = false    private lateinit var userPreference: UserPreference    private lateinit var webView: WebView    private lateinit var result: MutableList<String>    private var mVehicleId: Int = 0    private var mTrailerId: Int = 0    private var mCoDriverId: Int = 0    private var mDriverId: Int = 0    private var dutyIdPref: String? = null    private var dutyStartTimePref: String? = null    private lateinit var userDetails: UserDetails    private var vinDevice = ""    private var currentId: Int = 0    private lateinit var allSameEvent: List<EventLog>    private var currentEvent: EventLog = EventLog()    private lateinit var dialog: MaterialDialog    val mainHandler = Handler(Looper.getMainLooper())    private var mBinder: TrackerBinder? = null    val TAG = AppModel.TAG    val tmIf = IntentFilter()    val trackerIf = IntentFilter()    val tupIf = IntentFilter()    val dtcIf = IntentFilter()    val tviIf = IntentFilter()    val seIf = IntentFilter()    val spnIf = IntentFilter()    var resetClock: Boolean = true    private val constraints = Constraints.Builder()        .setRequiresBatteryNotLow(true)        //        .setRequiresCharging(true)        .setRequiredNetworkType(NetworkType.CONNECTED)        .build()    override fun onCreateView(        inflater: LayoutInflater, container: ViewGroup?,        savedInstanceState: Bundle?    ): View {        //Active the screen        activity?.window?.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)        AppUtils.logger("Step: Home Fragment view create")        binding = FragmentHomeBinding.inflate(inflater, container, false)        homeViewModel = ViewModelProvider(this, factory)[HomeViewModel::class.java]        dialog = activity?.let { MaterialDialog(it) }!!        userPreference = UserPreference(requireContext())        val time =            PreferenceHelper().getString(requireContext(), AppConstants.PREF_DUTY_START_TIME_STAMP)        if (time != null) {            if (time.isNotBlank() && time.isDigitsOnly())                prefDutyTime = time.toLong()        }        if (isDutyStarted()) {            var currentEvent = currentEvent()            var previousEvent = previousEvent()            if (!previousEvent.isNullOrEmpty()) {                stepDecider(previousEvent, currentEvent)            }            printRemainingDriveTime()            printRemainingSleepTime()            printRemainingOnDutyTime()            printRemainingClock70Time()        } else {            setDefaultClocksTime(with70Hour = true)        }        setLocation()        binding.viewmodel = homeViewModel        homeViewModel.downloadListener = this        truckNoAutoText = binding.vehicleNoAutoText        coDriverAutoText = binding.codriverAutotext        trailerAutoText = binding.trailerNoAutotext        binding.personalUseBtnLay.setOnClickListener(this)        binding.yardMoveBtnLayout.setOnClickListener(this)        binding.recapBtn.setOnClickListener(this)        binding.dotInspectionNo.setOnClickListener(this)        binding.shippingDocNo.setOnClickListener(this)        binding.dvirNo.setOnClickListener(this)        binding.driveBtn.setOnClickListener(this)        binding.sleepBtn.setOnClickListener(this)        binding.offDutyBtn.setOnClickListener(this)        binding.onDutyBtn.setOnClickListener(this)        tmIf.addAction("REFRESH")        trackerIf.addAction("TRACKER-REFRESH")        tupIf.addAction("TRACKER-UPDATE")        dtcIf.addAction("TRACKER-DTC-REFRESH")        dtcIf.addAction("TRACKER-DTC-CLEAR")        tviIf.addAction("TRACKER-VIN-REFRESH")        seIf.addAction("TRACKER-SE-REFRESH")        spnIf.addAction("TRACKER-SPN-REFRESH")        LocalBroadcastManager.getInstance(requireContext()).registerReceiver(tmRefresh, tmIf)        LocalBroadcastManager.getInstance(requireContext()).registerReceiver(tiRefresh, trackerIf)        LocalBroadcastManager.getInstance(requireContext()).registerReceiver(tupRefresh, tupIf)        LocalBroadcastManager.getInstance(requireContext()).registerReceiver(dtcRefresh, dtcIf)        LocalBroadcastManager.getInstance(requireContext()).registerReceiver(viRefresh, tviIf)        LocalBroadcastManager.getInstance(requireContext()).registerReceiver(seRefresh, seIf)        LocalBroadcastManager.getInstance(requireContext()).registerReceiver(spnRefresh, spnIf)        driverListArr = emptyList()        vehicleListArr = emptyList()        trailerListArr = emptyList()        mainScope.launch(exceptionHandler) {            val result = homeViewModel.viewModelScope.async {                homeViewModel.getUserDetail().observe(                    viewLifecycleOwner, Observer {                        if (it != null) {                            userDetails = it                            val driverName = userDetails.displayName                            if (driverName != null) {                                (activity as MainActivity).setActionBarTitle(driverName)                            }                            CoroutineScope(Dispatchers.IO).launch {                                userPreference.saveDriverId(it.id)                                userPreference.saveClientId(it.clientId)                                userDetails.displayName?.let { it1 ->                                    userPreference.saveCoDriverName(it1)                                }                            }                            downloadDropdownMaster(it)                            restoreStatus()                            clock()                        }                    }                )            }            result.wait()        }        initLiveData()        activity?.applicationContext?.let {            val workOutBound =                PeriodicWorkRequest.Builder(                    OutboundWorkManager::class.java,                    15, TimeUnit.MINUTES                )                    .setConstraints(constraints).build()            val workManager1 = WorkManager.getInstance(it)            workManager1.enqueueUniquePeriodicWork(                "workOutBound",                ExistingPeriodicWorkPolicy.REPLACE,                workOutBound            )        }        initVehicle()        initCoDriver()        initTrailer()        createChart()        sendInstantDataToServer()//        val funtimer: Timer = Timer()//        funtimer.scheduleAtFixedRate(//            timerTask()//            {//               AppUtils.logger("Timer is running")//                CoroutineScope(Dispatchers.IO).launch {//                    updateTelemetryInfo()//                }//            }, 20000, 30000)                return binding.root    }    fun Fragment.onBackPressedAction(action: () -> Boolean) {        requireActivity().onBackPressedDispatcher.addCallback(viewLifecycleOwner, object :            OnBackPressedCallback(true) {            override fun handleOnBackPressed() {                this.isEnabled = action()                if (!this.isEnabled) {                    requireActivity().onBackPressed()                }            }        })    }    override fun onDetach() {        LocalBroadcastManager.getInstance(requireContext()).unregisterReceiver(tmRefresh)        LocalBroadcastManager.getInstance(requireContext()).unregisterReceiver(tiRefresh)        LocalBroadcastManager.getInstance(requireContext()).unregisterReceiver(tupRefresh)        LocalBroadcastManager.getInstance(requireContext()).unregisterReceiver(dtcRefresh)        LocalBroadcastManager.getInstance(requireContext()).unregisterReceiver(viRefresh)        LocalBroadcastManager.getInstance(requireContext()).unregisterReceiver(seRefresh)        LocalBroadcastManager.getInstance(requireContext()).unregisterReceiver(spnRefresh)        super.onDetach()    }    private fun setLocation() {        AppUtils.logger("Step: SetLocation")        gpsTracker = GPSTracker(requireContext())        if (gpsTracker!!.canGetLocation()) {            val latitude = gpsTracker!!.getLatitude()            val longitude = gpsTracker!!.getLongitude()            //position found, show in map            if (latitude > 0)                getmAddress(latitude, longitude)        } else {            // can't get location            // GPS or Network is not enabled            // Ask user to enable GPS/network in settings            gpsTracker!!.showSettingsAlert()        }    }    private fun getmAddress(latitude: Double, longitude: Double) {        AppUtils.logger("Step: getmAddress, latitude $latitude longitude $longitude")        binding.progressBar.show()        val call =            RetrofitClient.getInstance().myApi.getAddress(latitude.toString(), longitude.toString())        call.enqueue(object : Callback<String?> {            override fun onResponse(call: Call<String?>, response: Response<String?>) {                myAddress = response.body().toString()                binding.progressBar.hide()                AppUtils.logger("Step: getmAddress $myAddress")            }            override fun onFailure(call: Call<String?>, t: Throwable) {                binding.progressBar.hide()                Toast.makeText(activity, "An error has occured", Toast.LENGTH_LONG).show()                AppUtils.logger("Step: getmAddress Error ")            }        })    }    var tmRefresh: BroadcastReceiver = object : BroadcastReceiver() {        override fun onReceive(context: Context, intent: Intent) {            updateTelemetryInfo()        }    }    var tiRefresh: BroadcastReceiver = object : BroadcastReceiver() {        override fun onReceive(context: Context, intent: Intent) {            updateTrackerInfo()        }    }    var tupRefresh: BroadcastReceiver = object : BroadcastReceiver() {        override fun onReceive(context: Context, intent: Intent) {            val action = intent.getIntExtra(TrackerService.EXTRA_RESP_ACTION_KEY, 0)            when (action) {                TrackerService.EXTRA_TRACKER_UPDATE_ACTION_UPDATED -> Toast.makeText(                    getContext(),                    "Tracker was successfully updated.",                    Toast.LENGTH_SHORT                ).show()                else -> {}            }        }    }    var dtcRefresh: BroadcastReceiver = object : BroadcastReceiver() {        override fun onReceive(context: Context, intent: Intent) {            val action = intent.getStringExtra(TrackerService.EXTRA_RESP_ACTION_KEY)            if (action == "GET") {                val dtc = AppModel.getInstance().mLastDTC                val sb = StringBuilder()                sb.append("Malfunction Indicator:").append(dtc.mDtc.mil).append("\n")                    .append("Bus:").append(dtc.mDtc.busType.name).append("\n")                if (dtc.mDtc.codes.size != 0) {                    for (code in dtc.mDtc.codes) {                        sb.append(code).append(",")                    }                    // remove the trailing comma                    val sz = sb.length                    sb.deleteCharAt(sz - 1)                } else {                    sb.append("No codes.")                }                val snackbar = Snackbar.make(                    activity!!.findViewById(android.R.id.content),                    sb.toString(),                    Snackbar.LENGTH_LONG                )                val textView =                    snackbar.view.findViewById<View>(com.google.android.material.R.id.snackbar_text) as TextView                textView.maxLines = 4                snackbar.view.setBackgroundColor(                    ContextCompat.getColor(                        requireContext(),                        R.color.colorSbSuccess                    )                )                snackbar.show()            } else if (action == "CLEAR") {                val status = intent.getIntExtra(TrackerService.EXTRA_RESP_STATUS_KEY, 0)                if (status == 0) {                    Toast.makeText(context, "DTC cleared!", Toast.LENGTH_LONG).show()                } else {                    Toast.makeText(context, "DTC clear failed!", Toast.LENGTH_LONG).show()                }            }        }    }    var viRefresh: BroadcastReceiver = object : BroadcastReceiver() {        override fun onReceive(context: Context, intent: Intent) {            updateVehicleInfo()        }    }    var spnRefresh: BroadcastReceiver = object : BroadcastReceiver() {        override fun onReceive(context: Context, intent: Intent) {            val sb = StringBuilder()            val fl = Math.round(AppModel.getInstance().mLastSPNEv.value * 0.4f)            sb.append("Tank 1 level: ").append(fl).append("%")            val snackbar = Snackbar.make(                activity!!.findViewById(android.R.id.content),                sb.toString(),                Snackbar.LENGTH_LONG            )            snackbar.view.setBackgroundColor(                ContextCompat.getColor(                    requireContext(),                    R.color.colorSbSuccess                )            )            snackbar.show()        }    }    fun updateTrackerInfo() {        if (getBinder() != null) {//            tvMac.setText(getBinder().getDeviceAddress())        }        if (AppModel.getInstance().mTrackerInfo != null) {            val ti = AppModel.getInstance().mTrackerInfo            if (ti.product != null) {//                tvModel.setText(ti.product)            } else {//                tvModel.setText("Generic")            }//            tvSerial.setText(ti.SN)            val ver = "F/W:" + ti.mvi.toString() + "  BLE:" + ti.bvi.toString()//            tvVersion.setText(ver)            if (ti.product.contains("30")) {//                tvVin.setText(AppModel.getInstance().mPT30Vin)                requireActivity().invalidateOptionsMenu()            }        } else if (getBinder() != null) {            val gti = GetTrackerInfo()            getBinder()?.getTracker()?.sendRequest(gti, null, null)        }//        tvUpTime.setText(upTimeToString());    }    fun updateVehicleInfo() {        if (AppModel.getInstance().mVehicleInfo != null) {            val vi = AppModel.getInstance().mVehicleInfo            vinDevice = vi.VIN?:""            Log.d("VIN", vinDevice)//            tvVin.setText(vi.VIN)        }    }    var seRefresh: BroadcastReceiver = object : BroadcastReceiver() {        override fun onReceive(context: Context, intent: Intent) {            updateSE()        }    }    fun updateSE() {        if (AppModel.getInstance().mLastSECount == 0) {//            vSETile.setVisibility(View.GONE)        } else {//            vSETile.setVisibility(View.VISIBLE)//            tvSEventCount.setText(AppModel.getInstance().mLastSECount.toString())        }        // Update Event        if (AppModel.getInstance().mLastSEvent != null) {//            tvSESeq.setText(AppModel.getInstance().mLastSEvent.mSeq.toString())//            tvSEvent.setText(AppModel.getInstance().mLastSEvent.mEvent.toString())        }        // Refresh count//        getStoredEventsCount()    }    private fun getStoredEventsCount() {        // Get Stored Events count        val gsec = GetStoredEventsCount()        Log.i(TrackerViewFragment.TAG, "Get Stored Events count ...$gsec")        if (getBinder() != null) {            getBinder()?.getTracker()?.sendRequest(gsec, null, null)        }    }    private fun ackStoredEvent(tm: TelemetryEvent) {        // Ack        val geoloc = tm.mGeoloc        val dt = tm.mDateTime        val params = StringBuilder()        val id = tm.mSeq        params.append("id=").append(id)            .append("&lat=").append(geoloc.latitude.toString())            .append("&lon=").append(geoloc.longitude.toString())            .append("&sat=").append(geoloc.satCount)            .append("&speed=").append(geoloc.speed)            .append("&head=").append(geoloc.heading)            .append("&date=").append(dt.date)            .append("&time=").append(dt.time)        // Do something        Log.i(TrackerViewFragment.TAG, "EVENT:" + tm.mEvent.toString() + ":" + tm.mSeq)        // ACK the event        val ack = AckStoredEvent(0, tm.mSeq.toString(), dt.toDateString())        getBinder()?.tracker?.sendResponse(ack, null, null)    }    fun getLastTelemetryEvent(): TelemetryEvent?{        if (AppModel.getInstance().mLastEvent != null) {            try {                return AppModel.getInstance().mLastEvent            } catch (e: java.lang.Exception){                e.printStackTrace()            }        }        return null    }    fun updateTelemetryInfo() {        if (AppModel.getInstance().mLastEvent != null)        {            try {                val te = getLastTelemetryEvent()//AppModel.getInstance()?.mLastEvent                //Uncomment this                if(te?.mEvent.toString().startsWith("BL")){                    Log.d("STORED EVENT FOUND:" , "${te?.mEvent.toString()} TIME: ${te?.mDateTime.toString()}" )                    getStoredEventsCount()                    saveUnidentifiedEvents(te!!)                    return                }//                tvEvent.setText(te.mEvent.toString())//                tvSeq.setText(te.mSeq.toString())//                tvDateTime.setText(te.mDateTime.toString())                val gp = te?.mGeoloc//                tvGeoloc.setText(gp.latitude.toString() + "/" + gp.longitude)//                tvGeolocExtra.setText(gp.heading.toString())//                tvSatStatus.setText("LOCK:" + (if (gp.isLocked) "1" else "0") + ", SAT:" + gp.satCount)//                if (swOdoUnit.isChecked()) {    // to Mile//                    val km = BigDecimal(te.mOdometer)//                    var miles = km.multiply(BigDecimal.valueOf(0.621371))//                    miles = miles.setScale(2, RoundingMode.FLOOR)//                    tvOdo.setText(miles.toString())//                } else {//                    tvOdo.setText(te.mOdometer)//                }//                tvVelo.setText(te.mVelocity)//                tvEh.setText(te.mEngineHours)//                tvRpm.setText(te.mRpm.toString())                //Log.d("EVENT TYPE:" , "${te?.mEvent.toString()} TIME: ${te?.mDateTime.toString()}" )                var speed = te?.mGeoloc?.speed                makeToast("Speed:$speed")                speed = 6 //For Test                if(speed == null){                    speed = 0                }                result = arrayListOf()                result.add(myAddress)//curr_loc                result.add("AUTO_LOC")//cust_loc                val od = te?.mOdometer?.substring(0, te.mOdometer.indexOf("."))//                val km = BigDecimal(te.mOdometer)//                var miles = km.multiply(BigDecimal.valueOf(0.621371))//                miles = miles.setScale(2, RoundingMode.FLOOR)                val miles = kilometerToMiles(od)                if (miles != null) {                    result.add(miles)//odometer                } else {                    result.add("0")//odometer                }                result.add("AUTO")//notes                var currentEventType = currentEvent()                var previousEvent = previousEvent()                Log.d("EVENT TYPE:" , "${"CurrentEvent: $currentEventType PreviousEvent : $previousEvent"}" )                if (checkValidation()) {                    if (speed != null) {                        if (speed > AppConstants.SPEED_CHECK) {                            if (dialog?.isShowing!!) {                                dialog.cancel()                            }                            PreferenceHelper().save(                                requireActivity(),                                AppConstants.LAST_PACKET_RECEIVED_TIME,                                System.currentTimeMillis().toString()                            )                            PreferenceHelper().save(                                requireActivity(),                                AppConstants.PREF_SHOW_ON_DUTY_DIALOG,                                true                            )                            //Log.d("SPEED:---", te.mGeoloc?.speed.toString())                            AppUtils.logger("EventType $currentEventType.eventType")                            when (currentEventType) {                                AppConstants.OFF_DUTY_TITLE -> {                                    if (isNewDutyIdRequired()) {                                        createNewDuty()                                    }                                    var eventTypeId = AppConstants.START_DUTY                                    var newEventType = AppConstants.START_DUTY_TITLE                                    result.add(newEventType)                                    result.add(eventTypeId.toString())                                    result.add("1")//split_sleep                                    stepDecider(previousEvent, newEventType)                                    saveDriverDutyInfo(eventTypeId.toString(), newEventType, true,                                        te?.mEngineHours)                                }                                AppConstants.START_DUTY_TITLE -> {                                    previousEvent = AppConstants.START_DUTY_TITLE                                    val eventTypeId = AppConstants.DRIVE                                    val newEventType = AppConstants.DRIVE_TITLE                                    result.add(newEventType)                                    result.add(eventTypeId.toString())                                    result.add("1")//split_sleep                                    AppUtils.logger("Save Driver Duty for Start Duty")                                    stepDecider(previousEvent, newEventType)                                    saveDriverDutyInfo(eventTypeId.toString(), newEventType, true,                                        te?.mEngineHours)                                }                                AppConstants.SLEEP_TITLE -> {                                    previousEvent = previousEvent()                                    val eventTypeId = AppConstants.DRIVE                                    val newEventType = AppConstants.DRIVE_TITLE                                    result.add(newEventType)                                    result.add(eventTypeId.toString())                                    result.add("1")//split_sleep                                    AppUtils.logger("Save Driver Duty for Sleep")                                    stepDecider(currentEventType, newEventType)                                    saveDriverDutyInfo(eventTypeId.toString(), newEventType, true,                                        te?.mEngineHours)                                }                            }                        } else {                            if (lastTimeStampOfSpeed() && currentEventType == AppConstants.DRIVE_TITLE) {                                val show = PreferenceHelper().getBoolean(                                    requireContext(),                                    AppConstants.PREF_SHOW_ON_DUTY_DIALOG,                                    true                                )                                if (show) {                                    Timer().schedule(                                        timerTask()                                        {                                            dialog.dismiss()                                            dialog.cancel()                                        }, 1000 * 2 * 60                                    )                                    dialog.show {                                        title(text = getString(R.string.dialog_title_alert))                                        message(                                            text = "Hi ${userDetails.displayName},\nYour vehicle is ideal from long time but you are On-Drive," +                                                    " you still want to be On-Drive or move to On-Duty," +                                                    " please confirm "                                        )                                        positiveButton(text = getString(R.string.yes)) {                                            AppUtils.logger("Dialog for confirmation yes click")                                            when (currentEventType/*currentEvent.eventType*/) {                                                AppConstants.DRIVE_TITLE -> {                                                    val eventTypeId = AppConstants.START_DUTY                                                    val eventType = AppConstants.START_DUTY_TITLE                                                    result.add(eventType)                                                    result.add(eventTypeId.toString())                                                    result.add("1")//split_sleep                                                    AppUtils.logger("Save Driver Duty for ON Duty")                                                    stepDecider(previousEvent, currentEventType)                                                    saveDriverDutyInfo(eventTypeId.toString(),eventType, true, te?.mEngineHours)                                                }                                            }                                        }                                        negativeButton(text = getString(R.string.no)) {                                            AppUtils.logger("Dialog for confirmation no click")                                            PreferenceHelper().save(                                                requireContext(),                                                AppConstants.PREF_SHOW_ON_DUTY_DIALOG,                                                false                                            )                                        }                                    }                                }                            }                            Log.d("SPEED:--->", te?.mGeoloc?.speed.toString())                        }                    }                }                //TODO uncomment this                //saveTimeTransMissionInOutbound(te!!)            } catch (e: java.lang.Exception) {                Log.e(TrackerViewFragment.TAG, e.fillInStackTrace().toString())            }        }    }    fun upgradeFromFile(filetype: Int) {        if (getBinder() != null) {            getBinder()!!.tracker.update(                requireContext(),                "file",                filetype.toLong(),                AppModel.getInstance().mFileContent            )            showUpdateProgressDialog()            AppModel.getInstance().mUpgradefromFileSelected = false        }    }    private fun showUpdateProgressDialog() {        val dialog = TrackerUpdateProgressFragment.getInstance()        dialog.show(            requireActivity().supportFragmentManager,            TrackerUpdateProgressFragment.FRAG_TAG        )    }    fun getBinder(): TrackerBinder? {        return if (mBinder != null) {            mBinder        } else {            //Toast.makeText(getContext(), "TVF:TNB!", Toast.LENGTH_SHORT).show();            null        }    }    private fun createChart() {        try {            AppUtils.logger("Step: createChart")            webView = binding.canvasChart            webView.webViewClient = WebViewClient()            //Enable Javascript for WebView            webView.settings.javaScriptEnabled = true            webView.settings.allowFileAccess = true            context?.let {                webView.addJavascriptInterface(JsWebInterface(it), "Interface")            }            webView.loadUrl("file:///android_asset/step-line-chart.html")            prepareChartData()        } catch (e: Exception) {            e.printStackTrace()            AppUtils.logger("Error in createChart")        }    }    private fun kilometerToMiles(valInKm: String?): String? {        val miles = (valInKm?.toDouble()?.div(1.609))        return miles?.toString()    }    class JsWebInterface(context: Context) {        val mContext = context        @JavascriptInterface        fun makeToast(str: String) {            Toast.makeText(mContext, str, Toast.LENGTH_LONG).show()        }        @JavascriptInterface        fun chartData(): String {            val result: JsonArray = Gson().toJsonTree(                chartInfo,                object : TypeToken<List<ChartInfo?>?>() {}.getType()            ) as JsonArray            return result.toString()        }    }    @RequiresApi(Build.VERSION_CODES.O)    private fun prepareChartData() {        AppUtils.logger("Step: prepareChartData")        val sharedPreference =            activity?.getSharedPreferences(AppConstants.PREF_DB, Context.MODE_PRIVATE)        val timeZone = sharedPreference?.getString(AppConstants.TIME_ZONE_KEY,"").toString()        //val timeZone = "America/Los_Angeles"        CoroutineScope(Dispatchers.IO).async {            try {                chartInfo = ArrayList<ChartInfo>();                chartInfo = homeViewModel.getChartData(AppUtils.getServerDateTime())                chartInfo.forEach {                    it.x = getDate(it.x, timeZone)                }                val res = chartInfo.distinctBy { x -> x.date }                var dateValue: LocalDate?                if(res.size > 0) {                    dateValue = LocalDate.parse(                        chartInfo.get(0).date,                        DateTimeFormatter.ofPattern("yyyy-MM-dd")                    )                } else {                    dateValue = LocalDate.now();                }                val currentDate: LocalDate? = LocalDate.now()                // There is no data available in device.                if (res?.isEmpty() == true) {                    var currentEvent = homeViewModel.getEventLogFromDb()                    var currentStats = currentEvent?.currentStatus                    if (currentStats == null) {                        currentStats = "OFF_DUTY"                    }                    // Add record for start mid night                    ChartInfo().apply {                        date = currentDate.toString()                        label = currentStats.toString()                        x = "$date 00:00"                    }.also {                        chartInfo.add(0, it);                    }                    // Add record for end current time                    ChartInfo().apply {                        date = currentDate.toString()                        label = currentStats.toString()                        x = LocalDateTime.now().toString()                        //x = timeZone?.let { AppUtils.timeZoneConverter(x, it) }.toString()                    }.also {                        chartInfo.add(chartInfo.size, it);                    }                } else {                    if (dateValue?.isBefore(currentDate) == true && res.size == 1) {                        //chartInfo = ArrayList<ChartInfo>();                        //val value: String = chartInfo.get(0).x                        val labelEventType: String = chartInfo.get(0).label                        val currentEventType: String = chartInfo.get(chartInfo.size - 1).label                        chartInfo = ArrayList<ChartInfo>();                        Log.d("info", dateValue.toString())                        Log.d("info", currentDate.toString())                        ChartInfo().apply {                            date = currentDate.toString()                            label = labelEventType                            x = "$date 00:00"                        }.also {                            chartInfo.add(0, it);                        }                        ChartInfo().apply {                            date = currentDate.toString()                            label = labelEventType                            x = LocalDateTime.now().toString()                            lineColor = "ORANGE"                        }.also {                            chartInfo.add(1, it);                        }                    } else {                        if (chartInfo.size == 1) {                            val labelEventType: String = chartInfo.get(0).label                            ChartInfo().apply {                                date = currentDate.toString()                                label = labelEventType                                x = "$date 00:00"                            }.also {                                chartInfo.add(0, it);                            }                        } else {                            val labelfirstEventType: String = chartInfo.get(0).label                            val labelCurrentEventType: String =                                chartInfo.get(chartInfo.size - 1).label                            // Add record for start mid night                            ChartInfo().apply {                                date = currentDate.toString()                                label = labelfirstEventType                                x = "$date 00:00"                            }.also {                                chartInfo.add(0, it);                            }                            // Add record for end current time                            ChartInfo().apply {                                date = currentDate.toString()                                label = labelCurrentEventType                                x = LocalDateTime.now().toString()                            }.also {                                chartInfo.add(chartInfo.size, it);                            }                        }                    }                }            } catch (ex: Exception) {                ex.printStackTrace();                //Log.d("Tag", ex.message.toString())            }        }    }    private fun getDate(ourDate: String, timeZone: String?): String {        var ourDate: String = ourDate        try {            val formatter = SimpleDateFormat("yyyy-MM-dd HH:mm:ss")            formatter.timeZone = TimeZone.getTimeZone("UTC")            val value = formatter.parse(ourDate)            val dateFormatter = SimpleDateFormat("yyyy-MM-dd HH:mm:ss") //this format changeable            dateFormatter.timeZone = TimeZone.getTimeZone(timeZone)            ourDate = dateFormatter.format(value)            Log.i("ourDate", ourDate);        } catch (e: java.lang.Exception) {            ourDate = "00-00-0000 00:00"        }        return ourDate    }    var calculateOnce = true    private fun clock() {        AppUtils.logger("Step: Clock Running")        try {            try {                mainHandler.removeCallbacksAndMessages(null)            } catch (e: Exception) {                e.printStackTrace()            }            mainHandler.post(object : Runnable {                override fun run() {                    try {                        CoroutineScope(Dispatchers.IO).async {                            currentEvent = homeViewModel.getEventLogFromDb()                        }                        when (currentEvent.currentStatus!!) {                            AppConstants.SLEEP_TITLE,                            AppConstants.SPLIT_SLEEP_TITLE -> {                                if (isDutyStarted() && calculateOnce) {                                    calculateNonSplitSleepTime()                                }                            }                            AppConstants.START_DUTY_TITLE -> {                            }                            AppConstants.DRIVE_TITLE -> {                            }                            AppConstants.OFF_DUTY_TITLE -> {                                if (isDutyStarted()) {                                    calculateOffDutyConsumedTime()                                }                            }                        }                    } catch (e: Exception) {                        e.printStackTrace()                        AppUtils.logger("Timer Error$e.message")                        if (currentEvent == null || currentEvent?.eventType == "") {                            getCurrentEvent()                        }                    }                    mainHandler.postDelayed(this, 10 * 1000)                }            })        } catch (e: Exception) {            e.printStackTrace()            AppUtils.logger("Timer Error$ + e.message")        }    }    override fun onClick(v: View?) {        setLocation()        when (v?.id) {            R.id.on_duty_btn -> {                if(!checkValidation()){                    return                }                calculateOnce = true                if (isClock70Completed()) {                    if (!isClock34Completed()) {                        makeToast(getString(R.string.clock_34_not_completed))                        makeToast("70 Hour Violation")                        createViolation(AppConstants.HOUR70_CYCLE_VIOLATION)                        openPostActivityCustom.launch(AppConstants.START_DUTY)                    }else{                        reloadData(startDuty = false, with70HourClock = true)                        setDefaultClocksTime(with70Hour = true)                        openPostActivityCustom.launch(AppConstants.START_DUTY)                    }                }else{                    openPostActivityCustom.launch(AppConstants.START_DUTY)                }            }            R.id.drive_btn -> {                if(!checkValidation()){                    return                }                calculateOnce = true                if (isClock70Completed()) {                    if (!isClock34Completed()) {                        makeToast(getString(R.string.clock_34_not_completed))                        makeToast("70 Hour Violation")                        createViolation(AppConstants.HOUR70_CYCLE_VIOLATION)                        openPostActivityCustom.launch(AppConstants.DRIVE)                    }else{                        openPostActivityCustom.launch(AppConstants.DRIVE)                    }                } else {                    AppUtils.logger("Step:  Click drive_btn")                    if (currentEvent == null || currentEvent?.currentStatus == AppConstants.OFF_DUTY_TITLE) {                        makeToast("Your duty is not started yet. Please start your duty first")                    } else if (!isDutyStarted()) {                        showStartDutyDialog()                    } else {                        openPostActivityCustom.launch(AppConstants.DRIVE)                    }                }            }            R.id.sleep_btn -> {                if(!checkValidation()){                    return                }                    calculateOnce = true                    if (isClock70Completed()) {                        if (!isClock34Completed()) {                            makeToast(getString(R.string.clock_34_not_completed))                            openPostActivityCustom.launch(AppConstants.SLEEP)                        } else {                            openPostActivityCustom.launch(AppConstants.SLEEP)                        }                    } else {                        if (currentEvent == null) {                            makeToast("Your duty is not started yet. Please start your duty first")                        } else if (!isDutyStarted()) {                            showStartDutyDialog()                        } else {                            openPostActivityCustom.launch(AppConstants.SLEEP)                        }                    }                }            R.id.off_duty_btn -> {                if(!checkValidation()){                    return                }                calculateOnce = true                if (isClock70Completed()) {                    if (!isClock34Completed()) {                        startClock34()                        openPostActivityCustom.launch(AppConstants.OFF_DUTY)                    } else {                        openPostActivityCustom.launch(AppConstants.OFF_DUTY)                    }                } else {                        AppUtils.logger("Step:  Click off_duty_btn")                        if (currentEvent == null) {                            makeToast("Your duty is not started yet. Please start your duty first")                        } else {                            openPostActivityCustom.launch(AppConstants.OFF_DUTY)                        }                    }                }            R.id.dvir_no_ -> {                AppUtils.logger("Step:  Click dvir_no_")                NavHostFragment.findNavController(this).navigate(R.id.nav_pretrip)            }            R.id.shipping_doc_no -> {                AppUtils.logger("Step:  Click shipping_doc_no")                NavHostFragment.findNavController(this).navigate(R.id.nav_shipping_doc)            }            R.id.dot_inspection_no -> {                AppUtils.logger("Step:  Click dot_inspection_no")                NavHostFragment.findNavController(this).navigate(R.id.nav_inspection)            }            R.id.recap_btn -> {                AppUtils.logger("Step:  Click recap_btn")                val intent = Intent(activity, RecapDialogueActivity::class.java)                startActivity(intent)            }            R.id.yard_move_btn_layout -> {                AppUtils.logger("Step:  Click yard_move_btn_layout")                if (currentEvent?.eventTypeId == AppConstants.START_DUTY) {                    openPostActivityCustom.launch(AppConstants.YARD_MOVE)                } else {                    dialog.show {                        title(text = getString(R.string.dialog_title_Msg))                        message(text = getString(R.string.yard_move_msg))                        positiveButton(text = getString(R.string.ok))                    }                }            }            R.id.personal_use_btn_lay -> {                //TODO Comment After the use//                reloadData()//                setDefaultClocksTime()//                setEventState(AppConstants.OFF_DUTY_TITLE, AppConstants.OFF_DUTY_TITLE)//////                pref.save(requireContext(), AppConstants.PREF_70_HOUR_CLOCK_TIME_STAMP,"")//                pref.save(requireContext(), AppConstants.REMAINING_70_HOUR,//                    AppConstants.TOTAL_70_HOURS_MILLI_SECONDS.toString()//                )////                pref.save(requireContext(), "SPLIT_MIN", false)//                pref.save(requireContext(), "SPLIT_MAX", false)//                pref.save(requireContext(), AppConstants.PREF_IS_FIRST_SPLIT_SLEEP,false)//                pref.save(requireContext(), AppConstants.PREF_IS_SECOND_SPLIT_SLEEP,false)//                pref.save(requireContext(), AppConstants.PREF_DRIVE_TIME_TILL_FIRST_SPLIT_SLEEP,  "")//////                pref.save(requireContext(), AppConstants.CLOCK_70_COMPLETED, false)//////                clock70HourTimerStarted = false//                var currentEvent = currentEvent()//                var previousEvent = previousEvent()//                if (!previousEvent.isNullOrEmpty()) {//                    stepDecider(previousEvent, currentEvent)//                }//                changeButtonColor(AppConstants.OFF_DUTY_TITLE)                    //TODO UnComment in final the use                AppUtils.logger("Step:  Click personal_use_btn_lay")                if (currentEvent?.eventTypeId == 0 || currentEvent?.eventTypeId == AppConstants.OFF_DUTY) {                    openPostActivityCustom.launch(AppConstants.PERSONAL_USE)                } else {                    dialog.show {                        title(text = getString(R.string.dialog_title_Msg))                        message(text = getString(R.string.personal_use_msg))                        positiveButton(text = getString(R.string.ok))                    }                }            }        }    }//    private fun newStatus(currentStatus: String, newStatus: String) {////        AppUtils.logger("Step: 4 NewStatus")//        AppUtils.logger("currentStatus$currentStatus, NewStatus:$newStatus")//        when (currentStatus) {////            AppConstants.START_DUTY_TITLE -> {//                //insert("currentStatus",  with current time  with new column isEventEnd=true)////                if (newStatus == AppConstants.SLEEP_TITLE || newStatus == AppConstants.OFF_DUTY_TITLE//                    || newStatus == AppConstants.PERSONAL_USE_TITLE//                ) {////                    //TODO Uncomment this @ Date 23AUG//                    /*saveDutyEventsInDb(//                        AppConstants.START_DUTY_END, AppConstants.START_DUTY_TITLE,//                        AppConstants.START_DUTY_TITLE, false//                    )*///                }////                updateOnDutyToNewStatus(newStatus)//            }////            AppConstants.OFF_DUTY_TITLE -> {////                resetAndCreateNewDuty()//////                if (newStatus == AppConstants.DRIVE_TITLE) {////                }////////                if (newStatus == AppConstants.SLEEP_TITLE) {////////                }////                if (newStatus == AppConstants.PERSONAL_USE_TITLE) {////////                }////                //TODO Uncomment this @ Date 23AUG//                /*saveDutyEventsInDb(//                    AppConstants.OFF_DUTY_END, AppConstants.OFF_DUTY_TITLE,//                    AppConstants.OFF_DUTY_TITLE, false//                )*///                updateOffDutyToNewStatus(newStatus)//                checkOnDutyViolation()//                checkDriveViolation()//            }////            AppConstants.DRIVE_TITLE -> {////                //PreferenceHelper().save(requireContext(), AppConstants.PREF_DRIVE_START_TIME_STAMP, System.currentTimeMillis().toString())////                //TODO Uncomment this @ Date 23AUG//                /*saveDutyEventsInDb(//                    AppConstants.DRIVE_END, AppConstants.DRIVE_TITLE,//                    AppConstants.DRIVE_TITLE, false//                )*/////                //TODO Uncomment this @ Date 23AUG//                /*saveDutyEventsInDb(//                    AppConstants.OFF_DUTY_END, AppConstants.OFF_DUTY_TITLE,//                    AppConstants.OFF_DUTY_TITLE, false//                )*///                updateDriveToNewStatus(newStatus)//                checkDrive30MinViolation()//            }////            AppConstants.SPLIT_SLEEP_TITLE,//            AppConstants.SLEEP_TITLE -> {//                //insert("currentStatus",  with current time  with new column isEventEnd=true)//                //TODO Uncomment this @ Date 23AUG//                /*saveDutyEventsInDb(//                    AppConstants.SLEEP_END, AppConstants.SLEEP_TITLE,//                    AppConstants.SLEEP_TITLE, false//                )*/////                updateSleepToNewStatus(newStatus)//                checkSleepViolation()////            }//        }//    }    override fun onHiddenChanged(hidden: Boolean) {        super.onHiddenChanged(hidden)    }//    private fun updateOnDutyToNewStatus(updateStatus: String) {////        AppUtils.logger("Step: 5 UpdateOnDutyToNewStatus")//        when (updateStatus) {////            AppConstants.START_DUTY_TITLE -> {////            }//            AppConstants.DRIVE_TITLE -> {//                PreferenceHelper().save(//                    requireContext(),//                    AppConstants.PREF_DRIVE_START_TIME_STAMP,//                    System.currentTimeMillis().toString()//                )//            }////            AppConstants.SPLIT_SLEEP_TITLE,//            AppConstants.SLEEP_TITLE -> {////                setOffDuty()////                CoroutineScope(Dispatchers.IO).launch {////                    saveSleepTime(updateStatus)////                }//            }////            AppConstants.OFF_DUTY_TITLE -> {////                setOffDuty()//                PreferenceHelper().save(//                    requireContext(),//                    AppConstants.PREF_OFF_DUTY_START_TIME,//                    System.currentTimeMillis().toString()//                )//                updateDutyEndTime(AppConstants.START_DUTY_TITLE)//            }//        }//    }    override fun onConfigurationChanged(newConfig: Configuration) {        super.onConfigurationChanged(newConfig)    }//    private fun updateDriveToNewStatus(updateStatus: String) {////        AppUtils.logger("Step: 10 UpdateDriveToNewStatus")////        updateDriveClock()////        when (updateStatus) {////            AppConstants.START_DUTY_TITLE -> {//                updateDutyEndTime(AppConstants.DRIVE_TITLE)////                val time = PreferenceHelper().getString(//                    requireContext(),//                    AppConstants.PREF_DUTY_START_TIME_STAMP//                )//                if (time != null) {//                    if (time.isNotBlank() && time.isDigitsOnly()) {//                        prefDutyTime = time.toLong()//                    } else {//                        prefDutyTime = System.currentTimeMillis()//                        PreferenceHelper().save(//                            requireContext(),//                            AppConstants.PREF_DUTY_START_TIME_STAMP,//                            System.currentTimeMillis().toString()//                        )//                    }//                }////            }////            AppConstants.DRIVE_TITLE -> {}////            AppConstants.SPLIT_SLEEP_TITLE,//            AppConstants.SLEEP_TITLE -> {////                setOffDuty()//                updateDutyEndTime(AppConstants.START_DUTY_TITLE)//                updateDutyEndTime(AppConstants.DRIVE_TITLE)//////                CoroutineScope(Dispatchers.IO).launch {////                    saveSleepTime(updateStatus)////                }//            }//////            AppConstants.OFF_DUTY_TITLE -> {////                setOffDuty()//                PreferenceHelper().save(//                    requireContext(),//                    AppConstants.PREF_OFF_DUTY_START_TIME,//                    System.currentTimeMillis().toString()//                )//                updateDutyEndTime(AppConstants.DRIVE_TITLE)//                updateDutyEndTime(AppConstants.START_DUTY_TITLE)////            }//        }//    }////    private fun updateSleepToNewStatus(updateStatus: String) {//////        CoroutineScope(Dispatchers.IO).launch {////            saveSleepTime(updateStatus)////        }////        when (updateStatus) {////            AppConstants.START_DUTY_TITLE -> {////                updateDutyEndTime(AppConstants.SLEEP_TITLE)////                setOnDuty()////                val time = PreferenceHelper().getString(//                    requireContext(),//                    AppConstants.PREF_DUTY_START_TIME_STAMP//                )//                if (time != null) {//                    if (time.isNotBlank() && time.isDigitsOnly()) {//                        prefDutyTime = time.toLong()//                    } else {//                        prefDutyTime = System.currentTimeMillis()//                        PreferenceHelper().save(//                            requireContext(),//                            AppConstants.PREF_DUTY_START_TIME_STAMP,//                            System.currentTimeMillis().toString()//                        )//                    }//                }//////                if (isSplitSleep()) {////////                } else {////////                    saveDutyEventsInDb(AppConstants.START_DUTY_TITLE, AppConstants.START_DUTY_TITLE)////                    val totalTime = (System.currentTimeMillis() - currentEvent.timeStampStart)////////                    if (totalTime < AppConstants.DUTY_SLEEP_HOURS) {////                        Log.d("===> Violation", "Sleep Violation")////                    }////                }////            }////            AppConstants.DRIVE_TITLE -> {////                PreferenceHelper().save(//                    requireContext(),//                    AppConstants.PREF_DRIVE_START_TIME_STAMP,//                    System.currentTimeMillis().toString()//                )//                val v = PreferenceHelper().getString(//                    requireContext(),//                    AppConstants.PREF_DRIVE_START_TIME_STAMP//                )//                AppUtils.logger("Step Save Time:$v")//////                setOnDuty()////                updateDutyEndTime(AppConstants.SLEEP_TITLE)//                saveDutyEventsInDb(//                    AppConstants.START_DUTY, AppConstants.START_DUTY_TITLE,//                    AppConstants.DRIVE_TITLE, true//                )////                //                val totalTime = (System.currentTimeMillis() - currentEvent.timeStampStart)//Changed here//                //                if (totalTime < AppConstants.DUTY_SLEEP_HOURS) {//                //                    Log.d("===> Violation", "Sleep Violation")//                //                }//            }////            AppConstants.SPLIT_SLEEP_TITLE,//            AppConstants.SLEEP_TITLE -> {//            }//            AppConstants.OFF_DUTY_TITLE -> {////                setOffDuty()//                PreferenceHelper().save(//                    requireContext(),//                    AppConstants.PREF_OFF_DUTY_START_TIME,//                    System.currentTimeMillis().toString()//                )//                updateDutyEndTime(AppConstants.SLEEP_TITLE)//            }//        }//    }    private fun updateDriveClock() {        val prefDriveStartTimeStamp =            PreferenceHelper().getString(requireContext(), AppConstants.PREF_DRIVE_START_TIME_STAMP)        AppUtils.logger("Step StartTime:$prefDriveStartTimeStamp")        prefDriveStartTimeStamp?.let {            try {                val driveTime = System.currentTimeMillis() - prefDriveStartTimeStamp.toLong()                var h: Int = (driveTime / (60 * 60 * 1000)).toInt()                var m: Int = ((driveTime / (60 * 1000)) % 60).toInt()                var s: Int = ((driveTime / 1000) % 60).toInt()                AppUtils.logger("Drive Time:$h:$m:$s")                val leftDriveTime = PreferenceHelper().getString(                    requireContext(),                    AppConstants.PREF_DRIVE_TIME_LEFT                )!!.toLong()                h = (leftDriveTime / (60 * 60 * 1000)).toInt()                m = ((leftDriveTime / (60 * 1000)) % 60).toInt()                s = ((leftDriveTime / 1000) % 60).toInt()                //AppUtils.logger("Step Previous Drive Time Left:$h:$m:$s")                val left = leftDriveTime - driveTime                //AppUtils.logger("Step Drive Time Left in mil:$left")                h = (left / (60 * 60 * 1000)).toInt()                m = ((left / (60 * 1000)) % 60).toInt()                s = ((left / 1000) % 60).toInt()                //AppUtils.logger("Step Drive Time Left now:$h:$m:$s")                PreferenceHelper().save(                    requireContext(),                    AppConstants.PREF_DRIVE_TIME_LEFT,                    "" + left                )            } catch (e: Exception) {                e.printStackTrace()            }        }    }//    private fun updateOffDutyToNewStatus(updateStatus: String) {////        AppUtils.logger("Step: 7 UpdateOffDutyToNewStatus")//        when (updateStatus) {////            AppConstants.START_DUTY_TITLE -> {//////                setOnDuty()////                val time = PreferenceHelper().getString(//                    requireContext(),//                    AppConstants.PREF_DUTY_START_TIME_STAMP//                )//                if (time != null) {//                    if (time.isNotBlank() && time.isDigitsOnly()) {//                        prefDutyTime = time.toLong()//                    } else {//                        prefDutyTime = System.currentTimeMillis()//                        PreferenceHelper().save(//                            requireContext(),//                            AppConstants.PREF_DUTY_START_TIME_STAMP,//                            System.currentTimeMillis().toString()//                        )//                    }//                }//////                dutyClock(AppConstants.TOTAL_DUTY_HOURS_MILLI_SECONDS.toLong())//            }////            AppConstants.DRIVE_TITLE -> {//                PreferenceHelper().save(//                    requireContext(),//                    AppConstants.PREF_DRIVE_START_TIME_STAMP,//                    System.currentTimeMillis().toString()//                )//                saveDutyEventsInDb(//                    AppConstants.START_DUTY, AppConstants.START_DUTY_TITLE,//                    AppConstants.DRIVE_TITLE, true//                )//                updateDutyEndTime(AppConstants.OFF_DUTY_TITLE)//            }////            AppConstants.SPLIT_SLEEP_TITLE,//            AppConstants.SLEEP_TITLE -> {//////                setOffDuty()////                CoroutineScope(Dispatchers.IO).launch {////                    saveSleepTime(updateStatus)////                }//            }////            AppConstants.OFF_DUTY_TITLE -> {//                PreferenceHelper().save(//                    requireContext(),//                    AppConstants.PREF_OFF_DUTY_START_TIME,//                    System.currentTimeMillis().toString()//                )//            }//        }//    }    private fun createNewDuty() {        AppUtils.logger("New Duty Created")        try {            val dutyId = AppUtils.findDutyNumber()            dutyIdPref = dutyId.toString()            homeViewModel.saveDutyIdPref(userPreference, dutyId.toString())            homeViewModel.saveDutyStartTimePref(                userPreference, System.currentTimeMillis().toString()            )            // PreferenceHelper().save(requireContext(), AppConstants.PREF_DUTY_START_TIME, System.currentTimeMillis().toString())            // prefDutyTime = System.currentTimeMillis()        } catch (e: Exception) {            e.printStackTrace()        }    }    /**     * Reset The Duty ID     *///    private fun resetAndCreateNewDuty() {////        try {//            val offDutyTimePref = PreferenceHelper().getString(//                requireContext(), AppConstants.PREF_OFF_DUTY_START_TIME//            )//            if (offDutyTimePref?.isNotBlank() == true) {//                val offDutyTime = System.currentTimeMillis() - offDutyTimePref.toLong()//////                if (offDutyTime > AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS) {//                    //makeToast("Start the new Duty")//                    pref.save(//                        requireContext(),//                        AppConstants.PREF_OFF_DUTY_START_TIME,//                        System.currentTimeMillis().toString()//                    )////                    CoroutineScope(Dispatchers.Main).launch {//                        dialog.show {//                            title(text = getString(R.string.dialog_title_Msg))//                            message(text = getString(R.string.complete_off_duty_hours))//                            positiveButton(text = getString(R.string.ok)) {//                                resetPref()//                            }//                        }//                    }//                }//            }//        } catch (//            e: Exception//        ) {//            e.printStackTrace()//            AppUtils.logger("Error: newStatus() ")//        }//    }    /**     * Reset The Duty ID     *///    private fun resetDuty() {////        homeViewModel.saveDutyIdPref(userPreference, "")//    }    /**     * Check validation that duty can be started or not     */    private fun checkValidation(): Boolean {        AppUtils.logger("Truck no. is selected")        when {            truckNoAutoText.text.toString() == "" -> {                //makeToast(getString(R.string.selected_vehicle))                dialog.show {                    title(text = getString(R.string.dialog_title_alert))                    message(text = getString(R.string.selected_vehicle))                    positiveButton(text = getString(R.string.ok))                }                return false            }//            trailerAutoText.text.toString() == "" -> {//                makeToast(getString(R.string.selected_trailer))//                return false//            }        }        return true    }    /***     * Disable and enable button after click     */    private fun enableAppBtn(disableView: TextView) {        binding.onDutyBtn.isEnabled = true        binding.offDutyBtn.isEnabled = true        binding.driveBtn.isEnabled = true        binding.sleepBtn.isEnabled = true        //Disable Button        disableView.isEnabled = false    }    /**     * Restore The buttons status after application exit.     */    private fun restoreStatus() {        AppUtils.logger("Step: RestoreStatus")        CoroutineScope(Dispatchers.IO).async {            currentEvent = homeViewModel.getEventLogFromDb()            CoroutineScope(Dispatchers.Main).launch {                when (currentEvent?.currentStatus) {                    AppConstants.START_DUTY_TITLE -> {                        //isDutyStart = true                        changeButtonColor(AppConstants.START_DUTY_TITLE)                        enableAppBtn(binding.onDutyBtn)                    }                    AppConstants.DRIVE_TITLE -> {                        //isDutyStart = true                        changeButtonColor(AppConstants.DRIVE_TITLE)                        enableAppBtn(binding.driveBtn)                    }                    AppConstants.SPLIT_SLEEP_TITLE,                    AppConstants.SLEEP_TITLE -> {                        //isDutyStart = true                        changeButtonColor(AppConstants.SLEEP_TITLE)                        enableAppBtn(binding.sleepBtn)                    }                    AppConstants.OFF_DUTY_TITLE -> {                        //isDutyStart = false                        changeButtonColor(AppConstants.OFF_DUTY_TITLE)                        enableAppBtn(binding.offDutyBtn)                        binding.sleepBtn.isEnabled = false                    }                }            }        }    }    private fun initVehicle() {        homeViewModel.getDropdownList(AppConstants.VEHICLE)            .observe(viewLifecycleOwner, Observer { vehicleList ->                vehicleListArr = vehicleList                val regList: ArrayList<String> = ArrayList()                for (vehicle in vehicleListArr) {                    regList.add(vehicle.name)                }                val vehicleNoAdapter = context?.let {                    ArrayAdapter(                        it, android.R.layout.simple_list_item_1, regList                    )                }                truckNoAutoText.setAdapter(vehicleNoAdapter)                truckNoAutoText.onItemClickListener =                    AdapterView.OnItemClickListener { parent, _, position, _ ->                        val selectedItem = parent.getItemAtPosition(position).toString()                        mVehicleId = vehicleList[position].code                        pref.save(                            requireContext(),                            AppConstants.VEHICLE_ID_KEY,                            mVehicleId                        )                        pref.save(                            requireContext(),                            AppConstants.VEHICLE_NO_KEY,                            selectedItem                        )                        lifecycleScope.launch {                            userPreference.saveTruckId(mVehicleId)                            userPreference.saveTruckNo(selectedItem)                        }                    }            })    }    private fun initCoDriver() {        homeViewModel.getDropdownList(AppConstants.CO_DRIVER)            .observe(viewLifecycleOwner) { driverList ->                driverListArr = driverList                val driverList: ArrayList<String> = ArrayList()                for (driver in driverListArr) {                    driverList.add(driver.name)                }                val driverAdapter = context?.let {                    ArrayAdapter(                        it, android.R.layout.simple_list_item_1, driverList                    )                }                coDriverAutoText.setAdapter(driverAdapter)                coDriverAutoText.onItemClickListener =                    AdapterView.OnItemClickListener { parent, _, position, _ ->                        val selectedItem = parent.getItemAtPosition(position).toString()                        Toast.makeText(                            context,                            "Selected : $selectedItem : $mCoDriverId",                            Toast.LENGTH_SHORT                        ).show()                        mCoDriverId = driverListArr[position].code                        lifecycleScope.launch {                            userPreference.saveCoDriverId(mCoDriverId)                            userPreference.saveCoDriverName(selectedItem)                        }                    }            }    }    private fun initTrailer() {        homeViewModel.getDropdownList(AppConstants.TRAILER)            .observe(viewLifecycleOwner) { trailerList ->                trailerListArr = trailerList                val trailerList: ArrayList<String> = ArrayList()                for (trailer in trailerListArr) {                    trailerList.add(trailer.name)                }                val trailerAdapter = context?.let {                    ArrayAdapter(                        it, android.R.layout.simple_list_item_1, trailerList                    )                }                trailerAutoText.setAdapter(trailerAdapter)                trailerAutoText.onItemClickListener =                    AdapterView.OnItemClickListener { parent, _, position, _ ->                        val selectedItem = parent.getItemAtPosition(position).toString()                        mTrailerId = trailerListArr[position].code//                        Toast.makeText(//                            context,//                            "Selected : $selectedItem : $mTrailerId",//                            Toast.LENGTH_SHORT//                        ).show()                        activity?.let { hideKeyboard(it) }                        pref.save(                            requireContext(),                            AppConstants.TRAILER_ID_KEY,                            mTrailerId                        )                        pref.save(                            requireContext(),                            AppConstants.TRAILER_NO_KEY,                            selectedItem                        )                        lifecycleScope.launch {                            userPreference.saveTrailerId(mTrailerId?.toInt()!!)                            userPreference.saveTrailerNo(selectedItem)                        }                    }            }    }    override suspend fun onSuccess(response: MasterResponse) {        binding.progressBar.hide()        print("Response Message:${response.status}")        materResponse = response        userPreference.setMasterSynced(userDetails.masterDataVersion?.toString()!!)    }    private fun downloadDropdownMaster(userDetails: UserDetails) {        AppUtils.logger("Step: DownloadDropdownMaster")        homeViewModel.viewModelScope.launch {            homeViewModel.getUserDetails().observe(                viewLifecycleOwner            ) {                userPreference.isSynced.asLiveData().observe(viewLifecycleOwner) { it ->                    Log.d("===Synced=====>", "$it")                    if (it == null || it == "" || it.toInt() != userDetails.masterDataVersion) {                        userDetails.key?.let {                            homeViewModel.downloadDropDownMaster(                                userDetails.id,                                userDetails.clientId,                                userDetails.key!!,                                ""                            )                        }                    }                }            }        }    }    override fun onStarted() {        binding.progressBar.show()    }    /**     * Get the current Activity     */    private fun getCurrentEvent(): EventLog {        AppUtils.logger("Step: 15 GetCurrentEvent")        CoroutineScope(Dispatchers.IO).async {            currentEvent = homeViewModel.getEventLogFromDb()            AppUtils.logger("Current Event: $currentEvent")            if (currentEvent == null) {                CoroutineScope(Dispatchers.Main).launch {                    if (isNewDutyIdRequired()) {                        createNewDuty()                    }                    if(!isClock70Completed()) {                        pref.save(requireContext(), AppConstants.PREF_70_HOUR_CLOCK_TIME_STAMP, "")                    }                    clock70HourTimerStarted = false                    reloadData(with70HourClock = true)                    setDefaultClocksTime(with70Hour = true)                    printRemainingClock70Time()                    setEventState(AppConstants.OFF_DUTY_TITLE, AppConstants.OFF_DUTY_TITLE)                    saveDutyEventsInDb(false)//                //resetButtonBg()                    setButtonTextColor(binding.offDutyBtn)                    binding.offDutyBtn.background = context?.let { it1 ->                        ContextCompat.getDrawable(it1, R.drawable.bg_circle_blue)                    }                }            }        }        return currentEvent    }//    /**//     * Get All the event By Event type//     *///    private fun getAllEventByType(dutyId: Long, eventType: String) {////        CoroutineScope(Dispatchers.IO).async {//            allSameEvent = homeViewModel.getAllEventByType(dutyId, eventType)//        }//    }    /**     * Check Duty Status     * 10 hours offduty or sleep     * then     */    private fun isNewDutyIdRequired(): Boolean {//        val dutyHour = AppConstants.TOTAL_DUTY_HOURS_MILLI_SECONDS        AppUtils.logger("Check New is required")        try {//            val time = PreferenceHelper().getString(requireContext(), AppConstants.PREF_DUTY_START_TIME)//            if (time != null) {//                if (time.isNotBlank() && time.isDigitsOnly())//                    prefDutyTime = time.toLong()//            }            if (dutyIdPref.isNullOrEmpty()) {                //PreferenceHelper().save(requireContext(),AppConstants.PREF_DRIVE_TIME_LEFT, AppConstants.TOTAL_DRIVE_HOURS_MILL_SECONDS.toString())                return true            }//            if (System.currentTimeMillis() > (prefDutyTime.plus(dutyHour))) {////                val isViolationGenerated = PreferenceHelper().getString(requireContext(), AppConstants.PREF_IS_DUTY_VIOLATION_GENERATED)//                if (isViolationGenerated != null) {//                    if (isViolationGenerated.isBlank())//                            checkOnDutyViolation()//                        }////                ////                PreferenceHelper().save(requireContext(),AppConstants.PREF_DRIVE_TIME_LEFT, AppConstants.TOTAL_DRIVE_HOURS_MILL_SECONDS.toString())////                //TODO//                //resetDutyId() //uncomment this//                AppUtils.logger( "Start New Duty and Close Old")//                return true//            }        } catch (e: Exception) {            //e.printStackTrace()            return true        }        AppUtils.logger("Continue Old due")        return false    }    /**     * Initialize all the data from Pref     */    private fun initLiveData() {        AppUtils.logger("Step: InitLiveData")//            homeViewModel.getUserDetail().observe(viewLifecycleOwner, Observer { user ->//                if (user != null) {////                    userDetails = user////                    val driverName = userDetails.displayName//                    if (driverName != null) {//                        (activity as MainActivity).setActionBarTitle(driverName)//                    }//                }//            })        userPreference.dutyId.asLiveData().observe(viewLifecycleOwner, Observer {            AppUtils.logger("===DutyId=====> $it")            if (it != null) {                dutyIdPref = it            }        })        userPreference.dutyStartTime.asLiveData().observe(viewLifecycleOwner, Observer {            AppUtils.logger("===DutyStartTime=====>$it")            if (it != null) {                dutyStartTimePref = it            }        })        truckNoAutoText.setText(            PreferenceHelper().getString(                requireContext(),                AppConstants.VEHICLE_NO_KEY            )        )//        userPreference.truckNumber.asLiveData().observe(this, Observer {//            Log.d("===TruckNo=====>", "$it")//            if (it != null) {//                truckNoAutoText.setText(it)//            }//        })        userPreference.driverName.asLiveData().observe(viewLifecycleOwner, Observer {            AppUtils.logger("===CoDriver=====>$it")            if (it != null) {                coDriverAutoText.setText(it)            }        })        trailerAutoText.setText(            PreferenceHelper().getString(                requireContext(),                AppConstants.TRAILER_NO_KEY            )        )//        userPreference.trailerNo.asLiveData().observe(this, Observer {//            Log.d("===TrailerNo=====>", "$it")//            if (it != null) {//                trailerAutoText.setText(it)//            }//        })        mVehicleId = PreferenceHelper().getInt(requireContext(), AppConstants.VEHICLE_ID_KEY)        userPreference.truckId.asLiveData().observe(viewLifecycleOwner, Observer {            AppUtils.logger("===TruckNoID=====>$it")            if (it != null) {                mVehicleId = it            }        })        userPreference.coDriverId.asLiveData().observe(viewLifecycleOwner, Observer {            AppUtils.logger("===CoDriverID=====>$it")            if (it != null) {                mCoDriverId = it            }        })        mTrailerId = PreferenceHelper().getInt(requireContext(), AppConstants.TRAILER_ID_KEY)//        userPreference.trailerId.asLiveData().observe(this, Observer {//            Log.d("===TrailerID=====>", "$it")//            if (it != null) {//                mTrailerId = it//            }//        })        userPreference.sleepSplit.asLiveData().observe(viewLifecycleOwner, Observer {            AppUtils.logger("===splitSleep=====>$it")            if (it != null) {                splitSleep = it!!            }        })        userPreference.authKey.asLiveData().observe(viewLifecycleOwner, Observer {            AppUtils.logger("===Auth Key=====>$it")            if (it != null) {                authKey = it!!            }        })    }    /**     * Save the Driver Event in Database     * eventAutoOrManual : Event is Auto generated or Manual     */    private fun saveDriverDutyInfo(eventType_Id: String, event_Type: String, eventAuto: Boolean,                                   enginHours: String?) {        AppUtils.logger("Step: 1 SaveDriverDutyInfo")        AppUtils.logger("Step: EventTypeId: $eventType_Id")        AppUtils.logger("Step: EventType: $event_Type")        //AppConstants.SPLIT_2_8        //AppConstants.SPLIT_3_7        if (event_Type == AppConstants.SLEEP_TITLE) {            if (isSplitEnable()) {                splitSleep = result[AppConstants.KEY_SLEEP_TYPE].toInt()            }            if (splitSleep > AppConstants.NO_SPLIT) {                saveSplitSleepInPref(splitSleep)            }        }        changeButtonColor(event_Type)        saveDriverInfoInDB()        saveDutyEventsInDb(true)        //Save Data to send @ ws        saveDutyEventsInOutbound(eventType_Id, "", "", eventAuto, enginHours)        getCurrentEvent()        clock()    }    private fun saveSplitSleepInPref(sleepMode: Int) {        CoroutineScope(Dispatchers.IO).async {            userPreference.sleepSplit(sleepMode)        }    }    private fun resetSplitSleep() {        CoroutineScope(Dispatchers.IO).async {            userPreference.sleepSplit(AppConstants.NO_SPLIT)        }    }    /**     * Reset and Pring Sleep     */    private fun reloadSleep(){        //Reset split sleep if sleep duration is < then min duration        pref.save(requireContext(), "SPLIT_PART_1", "")        pref.save(requireContext(), "SPLIT_MIN", false)        pref.save(requireContext(), "SPLIT_MAX", false)        pref.save(requireContext(), AppConstants.PREF_IS_FIRST_SPLIT_SLEEP,false)        pref.save(requireContext(), AppConstants.PREF_IS_SECOND_SPLIT_SLEEP,false)        pref.save(requireContext(), AppConstants.PREF_DRIVE_TIME_TILL_FIRST_SPLIT_SLEEP,  "")        saveSplitSleepInPref(AppConstants.NO_SPLIT)        pref.save(requireContext(),AppConstants.REMAINING_SLEEP,            AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS.toString())        val sleepHours: Int =            (AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS / (60 * 60 * 1000))        val sleepMinutes: Int =            ((AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS / (60 * 1000)) % 60)        val sleepTime = String.format("%02d:%02d", sleepHours, sleepMinutes)        binding.sleepTimer.text = sleepTime    }    private fun updateDutyEndTime(eventType: String) {        currentEvent?.let {            currentId = it.ID            val timeStampEnd = AppUtils.getServerDateTime()            homeViewModel.updateDutyEndTimeAndDuration(                eventType,                it.dutyId,                timeStampEnd,                false            )            sendInstantDataToServer()        }    }    private fun saveDriverInfoInDB() {        AppUtils.logger("Step: 3 SaveDriverInfoInDB")        DriverDutyInfo().apply {            clientId = userDetails.clientId            userId = userDetails.id            if (dutyIdPref?.isNotEmpty() == true) {                dutyId = dutyIdPref?.toLong()!!            }            driverName = userDetails.displayName            coDriverId = mCoDriverId            coDriverName = coDriverAutoText.text.toString()            vehicleId = mVehicleId            vehicleNo = truckNoAutoText.text.toString()            trailerId = mTrailerId            trailerNumber = trailerAutoText.text.toString()            currentLocation = result[AppConstants.KEY_CUR_LOC]            customLocation = result[AppConstants.KEY_CUSTOM_LOC]            currentOdometer = result[AppConstants.KEY_ODOMETER]            notes = result[AppConstants.KEY_NOTES]        }.also {            homeViewModel.saveDriverInfoInDB(it)            sendInstantDataToServer()        }    }    private fun saveDutyEventsInDb(withoutDuty: Boolean) {        AppUtils.logger("Step: 13 SaveDutyEventsInDb")        EventLog().apply {            clientId = userDetails.clientId            userId = userDetails.id            eventTime = AppUtils.getServerDateTime()            if (withoutDuty) {                if (dutyIdPref?.isNotEmpty() == true) {                    dutyId = dutyIdPref?.toLong()!!                }                vehicleId = mVehicleId                eventType = result[AppConstants.KEY_EVENT_TYPE]                eventTypeId = result[AppConstants.KEY_EVENT_ID].toInt()                coDriverId = mCoDriverId                trailerId = mTrailerId                location = result[AppConstants.KEY_CUR_LOC]                customLocation = result[AppConstants.KEY_CUSTOM_LOC]                odoMeter = result[AppConstants.KEY_ODOMETER]                notes = result[AppConstants.KEY_NOTES]                //            timeStampStart = System.currentTimeMillis()                currentStatus = if (eventType == AppConstants.SLEEP_TITLE) {                    if (isSplitSleep()) {                        AppConstants.SPLIT_SLEEP_TITLE                    } else {                        result[AppConstants.KEY_EVENT_TYPE]                    }                } else {                    result[AppConstants.KEY_EVENT_TYPE]                }            } else {                eventType = AppConstants.OFF_DUTY_TITLE                eventTypeId = AppConstants.OFF_DUTY.toInt()                currentStatus = AppConstants.OFF_DUTY_TITLE                dutyId = dutyIdPref?.toLong()!!                vehicleId = 1                coDriverId = 0                trailerId = 11                location = ""                customLocation = ""                odoMeter = "1"                notes = ""            }        }.also {            AppUtils.logger("Step: Save LAST_DRIVER_EVENT $it.eventType")            pref.save(requireContext(), AppConstants.LAST_DRIVER_EVENT, it.eventType)            saveDriverDutyEventInDb(it)            sendInstantDataToServer()        }    }    /**     * @paramm mEventTypeId     * @param mEventType     * @param mCurrentStatus     * @sync     *///    private fun saveDutyEventsInDb(//        mEventTypeId: Int,//        mEventType: String,//        mCurrentStatus: String,//        sync: Boolean//    ) {//        AppUtils.logger("Step: 6 SaveDutyEventsInDb")//        EventLog().apply {////            clientId = userDetails?.clientId!!//            userId = userDetails?.id!!//            dutyId = dutyIdPref?.toLong()!!//            eventType = mEventType//            eventTypeId = mEventTypeId//            currentStatus = mCurrentStatus//            //timeStampStart = System.currentTimeMillis()//            eventTime = AppUtils.getServerDateTime()//            vehicleId = mVehicleId//            coDriverId = mCoDriverId//            trailerId = mTrailerId////            location = result[AppConstants.KEY_CUR_LOC]//            customLocation = result[AppConstants.KEY_CUSTOM_LOC]//            odoMeter = result[AppConstants.KEY_ODOMETER]//            notes = result[AppConstants.KEY_NOTES]//            synced = sync//////        }.also {////            saveDriverDutyEventInDb(it)////            sendInstantDataToServer()//        }//    }    private fun saveDriverDutyEventInDb(eventLog: EventLog) {        val id = homeViewModel.saveEventLogInDb(eventLog)        Log.d("Event", "Inserted ID $id")    }    private fun changeButtonColor(eventType: String) {        AppUtils.logger("Step: 2 ChangeButtonColor")        CoroutineScope(Dispatchers.Main).async {            createChart()            when (eventType) {                AppConstants.START_DUTY_TITLE -> {                    activity?.let { hideKeyboard(it) }                    resetButtonBg()                    setButtonTextColor(binding.onDutyBtn)                    binding.onDutyBtn.background = context?.let { it1 ->                        ContextCompat.getDrawable(it1, R.drawable.bg_circle_blue)                    }                    enableAppBtn(binding.onDutyBtn)                }                AppConstants.DRIVE_TITLE -> {                    activity?.let { hideKeyboard(it) }                    resetButtonBg()                    setButtonTextColor(binding.driveBtn)                    binding.driveBtn.background = context?.let { it1 ->                        ContextCompat.getDrawable(it1, R.drawable.bg_circle_blue)                    }                    enableAppBtn(binding.driveBtn)                }                AppConstants.SPLIT_SLEEP_TITLE,                AppConstants.SLEEP_TITLE -> {                    activity?.let { hideKeyboard(it) }                    resetButtonBg()                    setButtonTextColor(binding.sleepBtn)                    binding.sleepBtn.requestFocus()                    binding.sleepBtn.background = context?.let { it1 ->                        ContextCompat.getDrawable(it1, R.drawable.bg_circle_blue)                    }                    enableAppBtn(binding.sleepBtn)                }                AppConstants.OFF_DUTY_TITLE -> {                    resetButtonBg()                    setButtonTextColor(binding.offDutyBtn)                    binding.offDutyBtn.background = context?.let { it1 ->                        ContextCompat.getDrawable(it1, R.drawable.bg_circle_blue)                    }                    enableAppBtn(binding.offDutyBtn)                    binding.sleepBtn.isEnabled = false                    resetSplitSleep()                    //resetDutyId()                }                AppConstants.PERSONAL_USE_TITLE -> {                }                AppConstants.YARD_MOVE_TITLE -> {                }            }        }    }    /**     * Send Duty Information @ Server via HTTP     */    private fun saveDutyEventsInOutbound(        eventTypeId: String,        eventEndTime: String,        eventDuration: String,        eventAuto: Boolean,        enginHours: String?    ) {        AppUtils.logger("Step: 14 saveDutyEventsInOutbound")        try {            val eventObj = JSONObject()            eventObj.put("userId", userDetails.id)            eventObj.put("eventTime", AppUtils.getServerDateTime())            eventObj.put("location", result[0])            eventObj.put("customLocation", result[1])            eventObj.put("odoMeter", result[2])            eventObj.put("coDriverId", mCoDriverId)            eventObj.put("vehicleId", mVehicleId)            eventObj.put("trailerId", mTrailerId)            eventObj.put("clientId", userDetails.clientId)            eventObj.put("notes", result[3])            eventObj.put("eventType", eventTypeId)            eventObj.put("dutyId", dutyIdPref)            eventObj.put("eventEndTime", eventEndTime)            eventObj.put("duration", eventDuration)            eventObj.put("engineHours", enginHours)            if(eventAuto){                eventObj.put("origin", "AUTO")            }else{                eventObj.put("origin", "MANUAL")            }            val mainObj = JSONObject()            mainObj.put(AppConstants.KEY_EVENTTYPE, AppConstants.EVENT_TYPE_DUTY)            mainObj.put(AppConstants.KEY_EVENT_DATA, eventObj)            Outbound().apply {                eventType = AppConstants.EVENT_TYPE_DUTY                data = mainObj.toString()                synced = false            }.also {                homeViewModel.insertOutboundData(it)                AppUtils.logger("DATA Inserted in Outbound ${eventObj.toString()}")                sendInstantDataToServer()            }        } catch (e: Exception) {            AppUtils.logger("Exception in save event in outbound${e.message}")        }    }    /**     * Send Duty Information @ Server via HTTP     */    private fun saveTimeTransMissionInOutbound(te: TelemetryEvent) {        try {            val eventObj = JSONObject()            eventObj.put("userId", userDetails.id)            eventObj.put("eventTime", AppUtils.getServerDateTime())            eventObj.put("dateTimeDevice", te.mDateTime)            eventObj.put("engineAge", te.mEngineAge)            eventObj.put("engineHours", te.mEngineHours)            eventObj.put("latitude", te.mGeoloc.latitude)            eventObj.put("longitude", te.mGeoloc.longitude)            eventObj.put("vehicleId", mVehicleId)            eventObj.put("ignitionStatus", "NA")            val od = te.mOdometer.substring(0, te.mOdometer.indexOf("."))            val miles = kilometerToMiles(od)            if (miles != null) {                eventObj.put("odometer", miles)            } else {                eventObj.put("odometer", 0)            }            eventObj.put("rpm", te.mRpm)            eventObj.put("seq", te.mSeq)            eventObj.put("velocity", te.mVelocity)            eventObj.put("odb2", te.obd2.isAvailable)            eventObj.put("engineTemp", "NA")            eventObj.put("speed", te.mGeoloc.speed)            val mainObj = JSONObject()            mainObj.put(AppConstants.KEY_EVENTTYPE, AppConstants.KEY_TIME_TRANS_MISSION)            mainObj.put(AppConstants.KEY_EVENT_DATA, eventObj)            Outbound().apply {                eventType = AppConstants.KEY_TIME_TRANS_MISSION                data = mainObj.toString()            }.also {                homeViewModel.insertOutboundData(it)                AppUtils.logger("DATA Inserted in Outbound $it")                sendInstantDataToServer()            }        } catch (e: Exception) {            AppUtils.logger("Exception in save event in outbound${e.message}")        }    }    /**     * Send Duty Information @ Server via HTTP     */    private fun saveUnidentifiedEvents(te: TelemetryEvent) {        try {            val event = UnidentifiedEvents()            event.userId = "0"            event.vehicleId = mVehicleId            event.vin = vinDevice            event.ignitionStatus = "NA"            event.eventTime = AppUtils.getServerDateTime()            event.eventTimeDevice = te.mDateTime.toString()            event.engineAge= te.mEngineAge.toString()            event.engineHours= te.mEngineHours            event.latitude = te.mGeoloc.latitude.toString()            event.longitude = te.mGeoloc.longitude.toString()            val od = te.mOdometer.substring(0, te.mOdometer.indexOf("."))            val miles = kilometerToMiles(od)            if (miles != null) {                event.odometer = miles            } else {                event.odometer= "0"            }            event.rpm = te.mRpm.toString()            event.seq = te.mSeq            event.velocity = te.mVelocity            event.odb2 = te.obd2.isAvailable.toString()            event.engineTemp =  "NA"            event.speed = te.mGeoloc.speed.toString()            event.synced = true            homeViewModel.insertUnidentifiedEvents(event)            AppUtils.logger("DATA Inserted in Outbound $event")            ackStoredEvent(te)        } catch (e: Exception) {            AppUtils.logger("Exception in save event in outbound${e.message}")        }    }    companion object {        var driveClockTime = 0L        var onDutyClockTime = 0L        var clock70HourTime = 0L        val pref = PreferenceHelper()        fun getAuthKey(): String {            return authKey        }        fun getSleepType(): Int {            return splitSleep        }        fun isSplitEnable(): Boolean {            if (splitSleep in 2..3) {                return false            }            return true        }        fun isSplitSleep(): Boolean {            if (splitSleep in 2..3) {                print("Split Sleep Enable")                return true            }            print("Split Sleep Disable")            return false        }    }    private fun checkDrive30MinViolation() {        AppUtils.logger("Step: 11 CheckDrive30MinViolation")        val totalDutyHours = AppConstants.DRIVE30_MIN_VIOLATION_HOURS.toLong()        try {            val parser = SimpleDateFormat(AppConstants.DATE_TIME_FORMAT_1)            val date = parser.parse(currentEvent?.eventTime!!)            val diff: Long = parser.parse(AppUtils.getServerDateTime())?.time!! - date?.time!!            val seconds = diff / 1000            val minutes = seconds / 60            val hours = minutes / 60            val days = hours / 24            Log.d("Diff===>", "$days Days $hours hours $minutes min $seconds sec")            if (hours > totalDutyHours) {                createViolation(AppConstants.MIN30_BREAK_VIOLATION)            }        } catch (e: Exception) {            e.printStackTrace()        }    }//    private fun checkDriveViolation() {////        AppUtils.logger("Step: 9 CheckDriveViolation")//        val totalDutyHours = AppConstants.DUTY_DRIVE_HOURS.toLong()////        CoroutineScope(Dispatchers.IO).async {//            val totalEventTime = homeViewModel.getTotalEventsTime(//                AppConstants.DRIVE_TITLE, currentEvent.dutyId//            )////            if (totalEventTime > totalDutyHours) {//                createViolation(AppConstants.DRIVE_VIOLATION)//            }//        }//    }////    private fun checkOnDutyViolation() {////        AppUtils.logger("Step: 8 CheckOnDutyViolation")//        val totalDutyHours = AppConstants.TOTAL_DUTY_HOURS.toLong()////        CoroutineScope(Dispatchers.IO).async {//            val totalEventTime = homeViewModel.getTotalEventsTime(//                AppConstants.START_DUTY_TITLE, currentEvent.dutyId//            )////            if (totalEventTime > totalDutyHours) {//                createViolation(AppConstants.ON_DUTY_ND_VIOLATION)//            }//        }//    }//////    private fun checkSleepViolation() {//        AppUtils.logger("Step: 12 checkSleepViolation")//        if (isSplitSleep()) {////            var min = 0//            when (getSleepType()) {//                AppConstants.SPLIT_7_3 -> {//                    min = AppConstants.SPLIT_7_3_MIN_TIME//                }//                AppConstants.SPLIT_8_2 -> {//                    min = AppConstants.SPLIT_8_2_MIN_TIME//                }//            }////            CoroutineScope(Dispatchers.IO).async {//                val totalEventTime = homeViewModel.getTotalEventsTime(//                    AppConstants.SLEEP_TITLE, currentEvent.dutyId//                )////                if (totalEventTime < min) {//                    createViolation(AppConstants.SLEEP_VIOLATION)//                }//            }////        } else {//////        }////    }    private fun createViolation(violation: Int) {        if(dutyIdPref.isNullOrEmpty()){            return        }        val violation = Violation().apply {            dutyId = dutyIdPref?.toLong()!!            userId = userDetails.id            vehicleId = mVehicleId            violationType = violation.toString()            violationTime = AppUtils.getServerDateTime()            synced = false        }.also {            homeViewModel.insertViolationInDb(it)        }        val jsonInString: String = Gson().toJson(violation)        val json = JSONObject(jsonInString)        val mainObj = JSONObject()            .put(AppConstants.KEY_EVENTTYPE, AppConstants.EVENT_TYPE_VIOLATION)            .put(AppConstants.KEY_EVENT_DATA, json)        Outbound().apply {            eventType = AppConstants.EVENT_TYPE_VIOLATION            data = mainObj.toString()            synced = false        }.also {            homeViewModel.insertOutboundData(it)            AppUtils.logger("DATA Inserted in Outbound $mainObj")            sendInstantDataToServer()        }    }    // Custom activity result contract    private val openPostActivityCustom =        registerForActivityResult(PostActivityContract()) { result ->            if (result != null && result.size > 0 && result[0] != "null") {                Log.d("==>", "Result : $result")                this.result = result                val eventTypeId = result[AppConstants.KEY_EVENT_ID]                val eventType = result[AppConstants.KEY_EVENT_TYPE]                val te = getLastTelemetryEvent()                saveDriverDutyInfo(eventTypeId, eventType, false, te?.mEngineHours?:"")                if(!isClock70Completed() || isClock34Completed()) {                    stepDecider(currentEvent(), eventType)                }else{                    setEventState(currentEvent(), eventType)                }            }        }    class PostActivityContract() : ActivityResultContract<Int, MutableList<String>>() {        override fun createIntent(context: Context, input: Int): Intent {            return Intent(context, HomeButtonDialogActivity::class.java).apply {                when (input) {                    AppConstants.START_DUTY -> {                        putExtra(AppConstants.TITLE, AppConstants.START_DUTY_TITLE)                        putExtra(AppConstants.EVENT_TYPE, AppConstants.START_DUTY)                    }                    AppConstants.DRIVE -> {                        putExtra(AppConstants.TITLE, AppConstants.DRIVE_TITLE)                        //putExtra(AppConstants.TITLE, myAddress)                        //myAddress                        putExtra(AppConstants.EVENT_TYPE, AppConstants.DRIVE)                    }                    AppConstants.SLEEP -> {                        putExtra(AppConstants.TITLE, AppConstants.SLEEP_TITLE)                        putExtra(AppConstants.EVENT_TYPE, AppConstants.SLEEP)                    }                    AppConstants.OFF_DUTY -> {                        putExtra(AppConstants.TITLE, AppConstants.OFF_DUTY_TITLE)                        putExtra(AppConstants.EVENT_TYPE, AppConstants.OFF_DUTY)                    }                    AppConstants.PERSONAL_USE -> {                        putExtra(AppConstants.TITLE, AppConstants.PERSONAL_USE_TITLE)                        putExtra(AppConstants.EVENT_TYPE, AppConstants.PERSONAL_USE)                    }                    AppConstants.YARD_MOVE -> {                        putExtra(AppConstants.TITLE, AppConstants.YARD_MOVE_TITLE)                        putExtra(AppConstants.EVENT_TYPE, AppConstants.YARD_MOVE)                    }                }            }        }        override fun parseResult(resultCode: Int, intent: Intent?): MutableList<String> {            val result: MutableList<String> = ArrayList()            val bundle: Bundle? = intent?.extras            result.add(bundle?.get("curr_loc").toString())            result.add(bundle?.get("cust_loc").toString())            result.add(bundle?.get("odometer").toString())            result.add(bundle?.get("notes").toString())            result.add(bundle?.get(AppConstants.EVENT_TYPE).toString())            result.add(bundle?.get("event_id").toString())            result.add(bundle?.get("split_sleep").toString())            return if (resultCode == Activity.RESULT_OK && result.size > 0) result            else result        }    }    private fun resetButtonBg() {        binding.onDutyBtn.background = context?.let { it1 ->            ContextCompat.getDrawable(                it1, R.drawable.home_circle_btn            )        }        binding.sleepBtn.background = context?.let { it1 ->            ContextCompat.getDrawable(                it1, R.drawable.home_circle_btn            )        }        binding.offDutyBtn.background = context?.let { it1 ->            ContextCompat.getDrawable(                it1, R.drawable.home_circle_btn            )        }        binding.driveBtn.background = context?.let { it1 ->            ContextCompat.getDrawable(                it1, R.drawable.home_circle_btn            )        }        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            activity?.resources?.let { it1 ->                binding.sleepBtn.setTextColor(it1.getColor(R.color.Blue_700, activity?.theme))                binding.onDutyBtn.setTextColor(it1.getColor(R.color.Blue_700, activity?.theme))                binding.driveBtn.setTextColor(it1.getColor(R.color.Blue_700, activity?.theme))                binding.offDutyBtn.setTextColor(it1.getColor(R.color.Blue_700, activity?.theme))            }        } else {            activity?.resources?.let { it1 -> binding.sleepBtn.setTextColor(it1.getColor(R.color.Blue_700)) }            activity?.resources?.let { it1 -> binding.onDutyBtn.setTextColor(it1.getColor(R.color.Blue_700)) }            activity?.resources?.let { it1 -> binding.driveBtn.setTextColor(it1.getColor(R.color.Blue_700)) }            activity?.resources?.let { it1 -> binding.offDutyBtn.setTextColor(it1.getColor(R.color.Blue_700)) }        }        resetClock = true    }    private fun setButtonTextColor(resource: TextView) {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            activity?.resources?.let { it1 ->                resource.setTextColor(it1.getColor(android.R.color.white, activity?.theme))            }        } else {            activity?.resources?.let { it1 -> resource.setTextColor(it1.getColor(android.R.color.white)) };        }    }    private fun hideKeyboard(activity: Activity) {        try {            val inputManager = activity                .getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager            val currentFocusedView = activity.currentFocus            if (currentFocusedView != null) {                inputManager.hideSoftInputFromWindow(                    currentFocusedView.windowToken,                    InputMethodManager.HIDE_NOT_ALWAYS                )            }        } catch (e: Exception) {            e.printStackTrace()        }    }    override fun onSuccess() {        binding.progressBar.hide()    }    override suspend fun onFailure(message: String) {        print("Error Message:$message")        binding.progressBar.hide()        withContext(Dispatchers.IO) {            userPreference.setMasterSynced("")        }        message?.let {            if (it.contains("${AppConstants.ERROR_CODE_NO_INTERNET}")) {                dialog.show {                    title(text = getString(R.string.dialog_title_alert))                    message(text = getString(R.string.internet_error))                    positiveButton(text = getString(R.string.ok))                }            } else {                activity?.toast(message)//                dialog.show {//                    title(text = getString(R.string.dialog_title_alert))//                    message(text = message)//                    positiveButton(text = getString(R.string.ok))//                }            }        }    }    override suspend fun onSuccess(response: BaseResponse) {        AppUtils.logger(response.toString())    }    override suspend fun onSuccess(response: DropdownMasterResponse) {        AppUtils.logger(response.toString())        withContext(Dispatchers.IO) {            homeViewModel.insertDropdownMaster(response.data)            userPreference.setMasterSynced(userDetails.masterDataVersion.toString())        }    }    override fun onServiceBound(binder: TrackerService.TrackerBinder?) {        // note: Binder may not be present, if this fragment was added in response to a broadcast from the existing service        mBinder = binder        Log.v(TrackerViewFragment.TAG, "TVF: onServiceBound:$this")    }    override fun onServiceUnbound() {        Log.v(TrackerViewFragment.TAG, "TVF: onServiceUnbound:$this")    }    private fun sendInstantDataToServer() {        activity?.let { mContext ->            if (AppUtils.isNetworkAvailable(mContext)) {                CoroutineScope(Dispatchers.IO).async {                    try {                        val mData = homeViewModel.getOutboundList(false)                        AppUtils.logger("One Time Work Manager Start")                        if (mData?.size!! > 0) {                            for (event in mData) {                                try {                                    val requestBody =                                        event.data?.toRequestBody()                                    AppUtils.loggerRequest("Offline Stored:$event.data")                                    if (!event.synced) {                                        val br = homeViewModel.sendOutBondDataToServer(                                            requestBody!!                                        )                                        val status = br.status                                        AppUtils.loggerResponse("$br")                                        status.let {                                            if (status.equals("success", true))                                                MyRoomDb.instance?.getOutboundDao()                                                    ?.update(event.ID, true)                                            AppUtils.deleteDataFromOutBound(event)                                        }                                    }                                } catch (err: Exception) {                                    err.message?.let { AppUtils.sentryLoggerError(it) }                                }                            }                        } else {                            AppUtils.logger("No Outbound data to sync")                        }                    } catch (e: Exception) {                        e.printStackTrace()                        e.message?.let { AppUtils.sentryLoggerError(it) }                    }                }                CoroutineScope(Dispatchers.IO).async {                    try {                        val mDataEvent = homeViewModel.getAllEvents(false)                        if (mDataEvent?.size!! > 0) {                            for (event in mDataEvent) {                                val jsonInString: String = Gson().toJson(event)                                val json = JSONObject(jsonInString)                                val mainObj = JSONObject()                                mainObj.put(                                    AppConstants.KEY_EVENTTYPE,                                    AppConstants.EVENT_TYPE_DUTY                                )                                mainObj.put(AppConstants.KEY_EVENT_DATA, json)                                val requestBody = mainObj.toString()                                    ?.toRequestBody("application/json".toMediaTypeOrNull())                                AppUtils.loggerRequest("$mainObj.toString()")                                val br = homeViewModel.sendOutBondDataToServer(requestBody!!)                                val status = br?.status                                AppUtils.loggerResponse("$br")                                status?.let {                                    if (status.equals("success", true)) {                                        MyRoomDb.instance?.getEventLogDao()                                            ?.updateSyncStatus(event.ID, true)                                        //MyRoomDb.instance?.getOutboundDao()?.delete(event)                                    } else {                                        AppUtils.sentryLoggerInfo(status)                                    }                                }                            }                        } else {                            AppUtils.logger("One Time work Manager no Event data to sync")                        }                        AppUtils.logger("One Time Work Manager status $Result.success()")                    } catch (e: Exception) {                        e.printStackTrace()                        AppUtils.logger("Timer Error$e.message")                        e.message?.let { AppUtils.loggerError(it) }                    }                }            } else {                AppUtils.logger("Network Not Available")            }        }    }    private fun lastTimeStampOfSpeed(): Boolean {        try {            val lastTimeStamp =                PreferenceHelper().getString(                    requireContext(),                    AppConstants.LAST_PACKET_RECEIVED_TIME                )            if (lastTimeStamp.isNullOrEmpty()) {                PreferenceHelper().save(                    requireContext(),                    AppConstants.LAST_PACKET_RECEIVED_TIME,                    System.currentTimeMillis().toString()                )            } else {                val totalTime =                    (System.currentTimeMillis() - lastTimeStamp?.toLong()!!) / (60 * 1000) % 60                AppUtils.logger("Speed Interval $totalTime min before")                if (totalTime > AppConstants.SPEED_TIME_INTERVAL) {                    return true                }            }            return false        } catch (e: Exception) {            e.printStackTrace()        }        return false    }    private fun calculateSplitSleep(sleepEnd: Boolean, newStatus: String) {        try {            var isSecondSleep = false            var needReset = true            var splitMin = pref.getBoolean(requireContext(), "SPLIT_MIN", false)            var splitMax = pref.getBoolean(requireContext(), "SPLIT_MAX", false)            if(splitMin || splitMax){                isSecondSleep = true            }            val isFirstSplitSleep = pref.getBoolean(requireContext(), AppConstants.PREF_IS_FIRST_SPLIT_SLEEP,                false)            val isSecondSplitSleep = pref.getBoolean(requireContext(), AppConstants.PREF_IS_SECOND_SPLIT_SLEEP,                false            )            //Violation Check            var min = 0            var max = 0            var sleepType = -1            var totalSplitSleepTime = 0L            sleepType = getSleepType()            when (sleepType) {                AppConstants.SPLIT_7_3 -> {                    min = AppConstants.SPLIT_7_3_MIN_TIME                    max = AppConstants.SPLIT_7_3_MAX_TIME                }                AppConstants.SPLIT_8_2 -> {                    min = AppConstants.SPLIT_8_2_MIN_TIME                    max = AppConstants.SPLIT_8_2_MAX_TIME                }            }            if (!isFirstSplitSleep && !sleepEnd) {                AppUtils.logger("First Sleep Start")                pref.save(requireContext(), AppConstants.PREF_IS_FIRST_SPLIT_SLEEP,true)                pref.save(requireContext(), "SPLIT_PART_1", System.currentTimeMillis().toString())                val consumedOnDuty = AppConstants.TOTAL_DUTY_HOURS_MILLI_SECONDS - onDutyClockTime                AppUtils.millisecondToTime("Remaining Duty Hours till First Sleep", consumedOnDuty)                pref.save(requireContext(), AppConstants.PREF_DUTY_TIME_TILL_FIRST_SPLIT_SLEEP, consumedOnDuty.toString())                val consumedDrive = AppConstants.TOTAL_DRIVE_HOURS_MILL_SECONDS - driveClockTime                AppUtils.millisecondToTime("Remaining Drive Hours till First Sleep", consumedDrive)                pref.save(requireContext(), AppConstants.PREF_DRIVE_TIME_TILL_FIRST_SPLIT_SLEEP,  consumedDrive.toString())            } else if (!isSecondSplitSleep && !sleepEnd) {                AppUtils.logger("Second Sleep Start")                pref.save(requireContext(), "SPLIT_PART_1", System.currentTimeMillis().toString())            } else if (sleepEnd) {                var startTimeSleep = pref.getString(requireContext(), "SPLIT_PART_1")                var sleepSpendTime = 0L                if (!startTimeSleep.isNullOrEmpty()) {                    sleepSpendTime = System.currentTimeMillis() - startTimeSleep.toLong()                }                if (sleepSpendTime > max && !splitMax) {                    pref.save(requireContext(), "SPLIT_MAX", true)                    if (!isSecondSleep){                    //Add into Duty Hours :- Split sleep Duration                    var splitSleepDuration = sleepSpendTime                    var remainingDutyHours = 0L                    remainingDutyHours = if (dutyTimerStarted) {                        onDutyClockTime                    } else {                        timeFromPref(AppConstants.REMAINING_ON_DUTY)                    }                    remainingDutyHours += splitSleepDuration                    AppUtils.millisecondToTime("Duty Hours After Update", remainingDutyHours)                    pref.save(requireContext(),                        AppConstants.REMAINING_ON_DUTY, remainingDutyHours.toString())                    if (this::onDutyTimer.isInitialized) {                        onDutyTimer.cancel()                    }                    startDuty(newStatus, forceReset = true)                    //Add into 70 Hour Clock: Split sleep Duration                    timeUpdate70HourClockToPref(                        AppConstants.REMAINING_70_HOUR,                        sleepSpendTime,                        false                    )                    //clock70HourStart(newStatus)                    if (this::on70HourTimer.isInitialized) {                        on70HourTimer.cancel()                    }                    clock70HourStart(newStatus, forceReset = true)                        pref.save(requireContext(), AppConstants.REMAINING_SLEEP, min.toString())                        printRemainingSleepTime()                }                    //Save 1st Split sleep duration                    pref.save(requireContext(),AppConstants.SPLIT_DURATION, sleepSpendTime.toString())                } else                if (sleepSpendTime > min && !splitMin) {                    pref.save(requireContext(), "SPLIT_MIN", true)                    if (!isSecondSleep) {                        //Step: 1 Add into Duty Hours :- Split sleep Duration                        var dutyHoursTillFirstSleepL = sleepSpendTime                        var remainingDutyHours = 0L                        remainingDutyHours = if (dutyTimerStarted) {                            onDutyClockTime                        } else {                            timeFromPref(AppConstants.REMAINING_ON_DUTY)                        }                        remainingDutyHours += dutyHoursTillFirstSleepL                        AppUtils.millisecondToTime("Duty Hours After Update", remainingDutyHours)                        pref.save(                            requireContext(),                            AppConstants.REMAINING_ON_DUTY,                            remainingDutyHours.toString()                        )                        if (this::onDutyTimer.isInitialized) {                            onDutyTimer.cancel()                        }                        startDuty(newStatus, forceReset = true)                        //Step: 2 Add into 70 Hour Clock: Split sleep Duration                        timeUpdate70HourClockToPref(                            AppConstants.REMAINING_70_HOUR,                            sleepSpendTime,                            false                        )                        if (this::on70HourTimer.isInitialized) {                            on70HourTimer.cancel()                        }                        clock70HourStart(newStatus, forceReset = true)                        pref.save(requireContext(), AppConstants.REMAINING_SLEEP, max.toString())                        printRemainingSleepTime()                    }                    //Save 1st Split sleep duration                    pref.save(requireContext(),AppConstants.SPLIT_DURATION, sleepSpendTime.toString())                }                var splitMin = pref.getBoolean(requireContext(), "SPLIT_MIN", false)                var splitMax = pref.getBoolean(requireContext(), "SPLIT_MAX", false)                if(isSecondSleep && (splitMax && splitMin)){                    //Allocate Drive time till 1st Sleep to Drive clock                    var timeStampStartMill = timeFromPref(AppConstants.PREF_DRIVE_TIME_TILL_FIRST_SPLIT_SLEEP)                    var remainingDriveHours = 0L                    remainingDriveHours = if (driveTimerStarted) {                        driveClockTime                    } else {                        timeFromPref(AppConstants.REMAINING_DRIVE)                    }                    AppUtils.millisecondToTime("Drive Hours Before 1st split sleep complete", remainingDriveHours)                    remainingDriveHours += timeStampStartMill                    AppUtils.millisecondToTime("Duty Hours After Update 2 sleep complete", remainingDriveHours)                    pref.save(requireContext(),AppConstants.REMAINING_DRIVE, remainingDriveHours.toString())                    printDriveTimeFromPref()                    if(newStatus == AppConstants.DRIVE_TITLE)                        driveStart(newStatus, forceReset = true)                    //-------------------------------                   //Add into Duty Hours :- Split sleep Duration                    var splitSleepDuration = sleepSpendTime                    var remainingDutyHours = 0L                    remainingDutyHours = if (dutyTimerStarted) {                        onDutyClockTime                    } else {                        timeFromPref(AppConstants.REMAINING_ON_DUTY)                    }                    AppUtils.millisecondToTime("Duty Hours Before Update 2 sleep complete", remainingDutyHours)                    remainingDutyHours += splitSleepDuration                    AppUtils.millisecondToTime("Duty Hours After Update 2 sleep complete", remainingDutyHours)                    pref.save(requireContext(), AppConstants.REMAINING_ON_DUTY,                        remainingDutyHours.toString()                    )                    if (this::onDutyTimer.isInitialized) {                        onDutyTimer.cancel()                    }                    startDuty(newStatus, forceReset = true)                    //Step: 2 Add into 70 Hour Clock: Split sleep Duration                    timeUpdate70HourClockToPref(AppConstants.REMAINING_70_HOUR, sleepSpendTime, false)                    if (this::on70HourTimer.isInitialized) {                        on70HourTimer.cancel()                    }                    clock70HourStart(newStatus, forceReset = true)                    //Reload sleep if successfully completed sleep.                    reloadSleep()                }else if(isSecondSleep && ((splitMax && !splitMin) || (!splitMax && splitMin))){                    val splitDuration = timeFromPref(AppConstants.SPLIT_DURATION)                    //Remove 1st split sleep duration from On-duty clock                    var remainingDutyHours = 0L                    remainingDutyHours = if(dutyTimerStarted){                        onDutyClockTime                    }else{                        timeFromPref(AppConstants.REMAINING_ON_DUTY)                    }                    AppUtils.millisecondToTime("Duty Hours Before Update", remainingDutyHours)                    remainingDutyHours -= splitDuration                    AppUtils.millisecondToTime("Duty Hours After Update", remainingDutyHours)                    pref.save(requireContext(),AppConstants.REMAINING_ON_DUTY, remainingDutyHours.toString())                    if (this::onDutyTimer.isInitialized) {                        onDutyTimer.cancel()                    }                    startDuty(newStatus, forceReset = true)                    //Remove 1st split sleep duration from Clock 70                    timeUpdate70HourClockToPref(AppConstants.REMAINING_70_HOUR, sleepSpendTime, true)                    if (this::on70HourTimer.isInitialized) {                        on70HourTimer.cancel()                    }                    clock70HourStart(newStatus, forceReset = true)                    //Reload sleep clock  if 1st completed successfully and 2nd sleep not completed                    reloadSleep()                } else if(!isSecondSleep && !splitMax && !splitMin){                    //Reload sleep clock  if split sleep not completed                    reloadSleep()                }            }        } catch (e: Exception) {            e.printStackTrace()            AppUtils.logger("Step: Error ${e.printStackTrace()}")        }    }    /**     * Calculate Non split sleep time & check whether time is > than total sleep time     */    private fun calculateNonSplitSleepTime() {        try {            var timeTemp = PreferenceHelper().getString(                requireContext(),                AppConstants.PREF_SLEEP_START_TIME_STAMP            ).toString()            var timeStampStart = 0L            var consumed = 0L            if (!timeTemp.isNullOrEmpty()) {                timeStampStart = timeTemp.toLong()                consumed = System.currentTimeMillis() - timeStampStart            }            //Add total remaining OD time to 70 hr CLOCK on completion of 10hr of sleep            if (consumed > AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS && calculateOnce) {                calculateOnce = false                CoroutineScope(Dispatchers.Main).launch {                    dialog.show {                        title(text = getString(R.string.dialog_title_Msg))                        message(text = getString(R.string.complete_sleep_hours))                        positiveButton(text = getString(R.string.ok)) {                            pref.save(requireContext(), AppConstants.PREF_70_HOUR_CLOCK_TIME_STAMP, "")                            //Get Duty Hours from pref                            var remainingDutyHours = timeFromPref(AppConstants.REMAINING_ON_DUTY_WHEN_SLEEP_START)//                            remainingDutyHours = if(dutyTimerStarted){//                                onDutyClockTime//                            }else{//                                timeFromPref(AppConstants.REMAINING_ON_DUTY)//                            }                            AppUtils.millisecondToTime("On Duty Remaining till Now", remainingDutyHours)                            var remainingClock70Hours = 0L                            if(clock70HourTimerStarted){                                remainingClock70Hours = clock70HourTime                            }else{                                remainingClock70Hours = timeFromPref(AppConstants.REMAINING_70_HOUR)                            }                            clock70HourTimerStarted = false                            AppUtils.millisecondToTime("Clock 70 Remaining till Now", remainingClock70Hours)                            remainingClock70Hours += remainingDutyHours                            AppUtils.millisecondToTime("Clock 70 After Update", remainingClock70Hours)                            pref.save(requireContext(),AppConstants.REMAINING_70_HOUR, remainingClock70Hours.toString())                            printRemainingClock70Time()                            reloadData()                            setDefaultClocksTime()//                            calculateOnce = true                            dialog.cancel()                        }                    }                    dialog.cancelOnTouchOutside(false)                }            }        } catch (e: Exception) {            e.printStackTrace()        }    }    /**     * check off Duty Consumed time     */    private fun calculateOffDutyConsumedTime() {        try {            var timeTemp = PreferenceHelper().getString(                requireContext(),                AppConstants.PREF_OFF_DUTY_START_TIME_STAMP            ).toString()            var timeStampStart = 0L            var consumed = 0L            if (!timeTemp.isNullOrEmpty()) {                timeStampStart = timeTemp.toLong()                consumed = System.currentTimeMillis() - timeStampStart            }            if (consumed > AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS) {                CoroutineScope(Dispatchers.Main).launch {                    dialog.show {                        title(text = getString(R.string.dialog_title_Msg))                        message(text = getString(R.string.complete_off_duty_hours))                        positiveButton(text = getString(R.string.ok)) {                            reloadData()                            setDefaultClocksTime()                        }                    }                }            }        } catch (e: Exception) {            e.printStackTrace()        }    }    private fun resetPref() {        pref.save(requireContext(), AppConstants.PREF_ON_DUTY_TIME_LEFT, "")        pref.save(requireContext(), AppConstants.PREF_TIME_DRIVE_LEFT, "")        pref.save(requireContext(), AppConstants.PREF_SLEEP_TIME_LEFT, "")        pref.save(requireContext(), AppConstants.PREF_SLEEP_START_TIME_STAMP, "")//        checkAndAssignCLockHoursPref()//        checkAndLoadPref()        //---------------------//        AppUtils.logger("Step: onFinish ResetPref")        pref.save(requireContext(), AppConstants.PREF_DUTY_START_TIME_STAMP, "")        pref.save(requireContext(), AppConstants.PREF_DRIVE_START_TIME_STAMP, "")        pref.save(requireContext(), AppConstants.PREF_DRIVE_TIME_LEFT, AppConstants.TOTAL_DRIVE_HOURS_MILL_SECONDS.toString())        pref.save(requireContext(), AppConstants.PREF_SLEEP_CLASS_OBJ, "")        pref.save(requireContext(), AppConstants.PREF_IS_FIRST_SPLIT_SLEEP, false)        pref.save(requireContext(), AppConstants.PREF_DRIVE_TIME_TILL_FIRST_SPLIT_SLEEP, "")        pref.save(requireContext(), AppConstants.PREF_DUTY_TIME_TILL_FIRST_SPLIT_SLEEP, "")        pref.save(requireContext(), AppConstants.PREF_IS_SECOND_SPLIT_SLEEP, false)        pref.save(requireContext(), AppConstants.PREF_SECOND_SLEEP_DRIVE_TIME, "")        pref.save(requireContext(), AppConstants.PREF_SECOND_SLEEP_DUTY_TIME, "")        pref.save(requireContext(), AppConstants.PREF_OFF_DUTY_START_TIME, "")        pref.save(requireContext(), AppConstants.PREF_IS_DUTY_STARTED, false)        resetSplitSleep()        setDefaultClocksTime()        if (currentEvent.eventType == AppConstants.SLEEP_TITLE) {            //setOffDuty()            //PreferenceHelper().save(requireContext(), AppConstants.PREF_DUTY_START_TIME, System.currentTimeMillis().toString())            //prefDutyTime = System.currentTimeMillis()            //saveSleepTime(AppConstants.SLEEP_TITLE)        } else {            createNewDuty()        }    }    private fun setDefaultClocksTime(with70Hour: Boolean = false) {        val sleepHours: Int = (AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS / (60 * 60 * 1000))        val sleepMinutes: Int = ((AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS / (60 * 1000)) % 60)        val sleepTime = String.format("%02d:%02d", sleepHours, sleepMinutes)        val driveHours: Int = (AppConstants.TOTAL_DRIVE_HOURS_MILL_SECONDS / (60 * 60 * 1000))        val driveMinutes: Int = ((AppConstants.TOTAL_DRIVE_HOURS_MILL_SECONDS / (60 * 1000)) % 60)        var driveHour = String.format("%02d:%02d", driveHours, driveMinutes)        val dutyHours: Int = (AppConstants.TOTAL_DUTY_HOURS_MILLI_SECONDS / (60 * 60 * 1000))        val dutyMinutes: Int = ((AppConstants.TOTAL_DUTY_HOURS_MILLI_SECONDS / (60 * 1000)) % 60)        var onDutyHour = String.format("%02d:%02d", dutyHours, dutyMinutes)        if(with70Hour){            val hours70: Int = (AppConstants.TOTAL_70_HOURS_MILLI_SECONDS / (60 * 60 * 1000))            val minutes70: Int = ((AppConstants.TOTAL_70_HOURS_MILLI_SECONDS / (60 * 1000)) % 60)            var hour70 = String.format("%02d:%02d", hours70, minutes70)            binding.timer70Hour.text = hour70        }        binding.sleepTimer.text = sleepTime        binding.onDutyTimeLeft.text = onDutyHour        binding.driveTimer.text = driveHour    }    private fun printRemainingDriveTime() {        var consumed = 0L        var remainingTime = timeFromPref(AppConstants.REMAINING_DRIVE)//PreferenceHelper().getString(requireContext(), "REMAINING_DRIVE")//        var remainingime = 0L//        if (!remainingPref.isNullOrEmpty()) {//            remainingime = remainingPref.toLong()////        }        var timeTemp = timeFromPref(AppConstants.PREF_DRIVE_START_TIME_STAMP)//pref.getString(requireContext(), AppConstants.PREF_DRIVE_START_TIME_STAMP).toString()//        var timeStampStart = 0L//        if (!timeTemp.isNullOrEmpty()) {//            timeStampStart = timeTemp.toLong()//            consumed = System.currentTimeMillis() - timeStampStart//        }        consumed = System.currentTimeMillis() - timeTemp        if(!driveTimerStarted){            consumed = remainingTime        }            if(consumed > 0){            val hours: Int = (consumed / (60 * 60 * 1000)).toInt()            val minutes: Int = ((consumed / (60 * 1000)) % 60).toInt()            val sec: Int = ((consumed / 1000) % 60).toInt()            AppUtils.logger("Print Remaining Drive Time: $hours:$minutes:$sec")            if (hours < 0 || minutes < 0) {                var dutyHour = String.format("%02d:%02d:%02d", 0, 0, 0)                CoroutineScope(Dispatchers.Main).launch {                    binding.driveTimer.text = dutyHour                }            } else {                var dutyHour = String.format("%02d:%02d:%02d", hours, minutes, sec)                CoroutineScope(Dispatchers.Main).launch {                    binding.driveTimer.text = dutyHour                }            }        }    }    private fun printDriveTimeFromPref() {        var remainingTime = timeFromPref(AppConstants.REMAINING_DRIVE)        if(remainingTime > 0){            val hours: Int = (remainingTime / (60 * 60 * 1000)).toInt()            val minutes: Int = ((remainingTime / (60 * 1000)) % 60).toInt()            val sec: Int = ((remainingTime / 1000) % 60).toInt()            AppUtils.logger("Print Remaining Drive Time Pref: $hours:$minutes:$sec")            if (hours < 0 || minutes < 0) {                var dutyHour = String.format("%02d:%02d:%02d", 0, 0, 0)                CoroutineScope(Dispatchers.Main).launch {                    binding.driveTimer.text = dutyHour                }            } else {                var dutyHour = String.format("%02d:%02d:%02d", hours, minutes, sec)                CoroutineScope(Dispatchers.Main).launch {                    binding.driveTimer.text = dutyHour                }            }        }    }    private fun printRemainingSleepTime() {//        var timeTemp =//            PreferenceHelper().getString(requireContext(), AppConstants.PREF_SLEEP_START_TIME_STAMP)//                .toString()//        var timeStampStart = 0L//        if (!timeTemp.isNullOrEmpty()) {//            timeStampStart = timeTemp.toLong()//        }        var remainingPref = PreferenceHelper().getString(requireContext(), AppConstants.REMAINING_SLEEP)//        val consumed = System.currentTimeMillis() - timeStampStart        //val leftTime = remainingPref?.toLong()!! - consumed        var remainingL = 0L        if (!remainingPref.isNullOrEmpty()) {            remainingL = remainingPref.toLong()        }        val leftTime = remainingL// - consumed        val hours: Int = (leftTime / (60 * 60 * 1000)).toInt()        val minutes: Int = ((leftTime / (60 * 1000)) % 60).toInt()        val sec: Int = ((leftTime / 1000) % 60).toInt()        AppUtils.logger("Print Remaining Sleep Time: $hours:$minutes:$sec")        if (hours < 0 || minutes < 0) {            var dutyHour = String.format("%02d:%02d:%02d", 0, 0, 0)            CoroutineScope(Dispatchers.Main).launch {                binding.sleepTimer.text = dutyHour            }        } else {            var dutyHour = String.format("%02d:%02d:%02d", hours, minutes, sec)            CoroutineScope(Dispatchers.Main).launch {                binding.sleepTimer.text = dutyHour            }        }    }    private fun printRemainingOnDutyTime() {        var timeTemp = pref.getString(requireContext(), AppConstants.PREF_DUTY_START_TIME_STAMP).toString()//        var currentEvent = currentEvent()        var timeStampStart = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStart = timeTemp.toLong()        }//        var remainingPref = PreferenceHelper().getString(requireContext(), "REMAINING_ON_DUTY")        val consumed = System.currentTimeMillis() - timeStampStart        //val leftTime = remainingPref?.toLong()!! - consumed//        var remainingL = 0L//        if (!remainingPref.isNullOrEmpty()) {//            remainingL = remainingPref.toLong()//        }//        val leftTime = remainingL// - consumed//        var leftTime = 0L//        leftTime = if (currentEvent == AppConstants.START_DUTY_TITLE) {//            remainingL - consumed//        } else {//            remainingL//        }            val hours: Int = (consumed / (60 * 60 * 1000)).toInt()            val minutes: Int = ((consumed / (60 * 1000)) % 60).toInt()            val sec: Int = ((consumed / 1000) % 60).toInt()            AppUtils.logger("Print Remaining Duty Time: $hours:$minutes:$sec")            if (hours < 0 || minutes < 0) {                var dutyHour = String.format("%02d:%02d:%02d", 0, 0, 0)                CoroutineScope(Dispatchers.Main).launch {                    binding.onDutyTimeLeft.text = dutyHour                }            } else {                var dutyHour = String.format("%02d:%02d:%02d", hours, minutes, sec)                CoroutineScope(Dispatchers.Main).launch {                    binding.onDutyTimeLeft.text = dutyHour                }            }    }    private fun printRemainingClock70Time() {        var remaining70hourPref = timeFromPref(AppConstants.REMAINING_70_HOUR)        var timeTempStart = timeFromPref(AppConstants.PREF_70_HOUR_CLOCK_TIME_STAMP)        var consumed = 0L        AppUtils.millisecondToTime("Print Clock 70 Remaining Time:",timeTempStart)        if(timeTempStart == 0L) {            consumed = 0L        }else{            consumed = System.currentTimeMillis() - timeTempStart        }        val actualTime = remaining70hourPref - consumed        val hours: Int = (actualTime / (60 * 60 * 1000)).toInt()        val minutes: Int = ((actualTime / (60 * 1000)) % 60).toInt()        val sec: Int = ((actualTime / 1000) % 60).toInt()        AppUtils.logger("Print Remaining Clock 70 Time: $hours:$minutes:$sec")        if (hours < 0 || minutes < 0) {            var dutyHour = String.format("%02d:%02d:%02d", 0, 0, 0)            CoroutineScope(Dispatchers.Main).launch {                binding.timer70Hour.text = dutyHour            }        } else {            var dutyHour = String.format("%02d:%02d:%02d", hours, minutes, sec)            CoroutineScope(Dispatchers.Main).launch {                binding.timer70Hour.text = dutyHour            }        }    }    private fun makeToast(msg: String) {        CoroutineScope(Dispatchers.Main).launch {            Toast.makeText(activity, msg, Toast.LENGTH_LONG).show();        }    }    private fun stepDecider(current: String, newStatus: String) {        when (current) {            AppConstants.START_DUTY_TITLE -> {                executeOnDutyToNewStatus(current, newStatus)            }            AppConstants.DRIVE_TITLE -> {                executeDriveToNewStatus(current, newStatus)            }            AppConstants.SLEEP_TITLE -> {                executeSleepToNewStatus(current, newStatus)            }            AppConstants.OFF_DUTY_TITLE -> {                executeOffDutyToNewStatus(current, newStatus)            }        }    }    private fun setEventState(currentEvent: String?, newEvent: String?) {            pref.save(requireContext(), AppConstants.PREF_PREVIOUS_EVENT,currentEvent ?: "")            pref.save(requireContext(), AppConstants.PREF_CURRENT_EVENT,newEvent ?: "")    }    fun currentEvent(): String {        return pref.getString(requireContext(), AppConstants.PREF_CURRENT_EVENT)            .toString()    }    private fun previousEvent(): String {        return pref.getString(requireContext(), AppConstants.PREF_PREVIOUS_EVENT)            .toString()    }    private fun executeOnDutyToNewStatus(currentEvent: String, newStatus: String) {        when (newStatus) {            AppConstants.DRIVE_TITLE -> {                if (!dutyTimerStarted) {                    startDuty(newStatus)                }                if (!driveTimerStarted) {                    driveStart(newStatus)                }                if (!clock70HourTimerStarted) {                    clock70HourStart(newStatus)                }            }            AppConstants.SLEEP_TITLE -> {                if (!dutyTimerStarted) {                    startDuty(newStatus)                }                if (driveTimerStarted) {                    driveEnd()                }                if (!sleepTimerStarted) {                    sleepStart(newStatus)                }                if(!clock70HourTimerStarted) {                    clock70HourStart(newStatus)                }            }            AppConstants.OFF_DUTY_TITLE -> {                if (!offDutyTimerStarted) {                    offDutyStart(newStatus)                }                if (isDutyStarted()) {                    if (!dutyTimerStarted) {                        startDuty(newStatus)                    }                    if (!clock70HourTimerStarted) {                        clock70HourStart(newStatus)                    }                } else {//                    if(isDutyStarted()){//                        if(!dutyTimerStarted) {//                            startDuty(newStatus)//                        }//                    }else{//                        if(dutyTimerStarted) {//                            endDuty()//                        }//                    }//                    if(!sleepTimerStarted) {//                        sleepStart(newStatus)//                    }//                    if(driveTimerStarted) {//                        driveEnd()//                    }                }            }        }    }    private fun executeDriveToNewStatus(currentEvent: String, newStatus: String) {        when (newStatus) {            AppConstants.START_DUTY_TITLE -> {                if (!dutyTimerStarted) {                    startDuty(newStatus)                } else {                    setEventState(currentEvent, newStatus)                }                if (driveTimerStarted) {                    driveEnd()                }                if(!clock70HourTimerStarted) {                    clock70HourStart(newStatus)                }            }            AppConstants.SLEEP_TITLE -> {                if (isDutyStarted()) {                    if (!dutyTimerStarted) {                        startDuty(newStatus)                    }                } else {                    if (dutyTimerStarted) {                        endDuty()                    }                }                if (!sleepTimerStarted) {                    sleepStart(newStatus)                }                if (driveTimerStarted) {                    driveEnd()                }                if(!clock70HourTimerStarted) {                    clock70HourStart(newStatus)                }            }            AppConstants.OFF_DUTY_TITLE -> {                if (!offDutyTimerStarted) {                    offDutyStart(newStatus)                }                if (isDutyStarted()) {                    if (!dutyTimerStarted) {                        startDuty(newStatus)                    }                    if (driveTimerStarted) {                        driveEnd()                    }                    if(clock70HourTimerStarted) {                        clock70End()                    }                } else {                    if (dutyTimerStarted) {                        endDuty()                    }                    if (sleepTimerStarted) {                        sleepEnd(newStatus)                    }                    if (driveTimerStarted) {                        driveEnd()                    }                    if(clock70HourTimerStarted) {                        clock70End()                    }                }            }        }    }    private fun executeSleepToNewStatus(currentEvent: String, newStatus: String) {        when (newStatus) {            AppConstants.START_DUTY_TITLE -> {                if (isDutyStarted()) {                    if (!dutyTimerStarted) {                        startDuty(newStatus)                    } else {                        setEventState(currentEvent, newStatus)                    }                    if(!clock70HourTimerStarted) {                        clock70HourStart(newStatus)                    }                } else {                    startNewDuty(true)                    startDuty(newStatus)                    if(!clock70HourTimerStarted) {                        clock70HourStart(newEvent = newStatus, forceReset = true)                    }                }                if (sleepTimerStarted) {                    sleepEnd(newStatus)                }            }            AppConstants.DRIVE_TITLE -> {                if (sleepTimerStarted) {                    sleepEnd(newStatus)                }                if (!driveTimerStarted) {                    driveStart(newStatus)                }                if (!dutyTimerStarted) {                    startDuty(newStatus)                }                if(!clock70HourTimerStarted) {                    clock70HourStart(newStatus)                }            }            AppConstants.OFF_DUTY_TITLE -> {                if (!offDutyTimerStarted) {                    offDutyStart(newStatus)                }                if (isDutyStarted()) {                    if (!dutyTimerStarted) {                        startDuty(newStatus)                    }                    if (sleepTimerStarted) {                        sleepEnd(newStatus)                    }                    if (driveTimerStarted) {                        driveEnd()                    }                    if(!clock70HourTimerStarted) {                        clock70HourStart(newStatus)                    }                } else {                    if (dutyTimerStarted) {                        endDuty()                    }                    if (driveTimerStarted) {                        driveEnd()                    }                    if (sleepTimerStarted) {                        sleepEnd(newStatus)                    }                    if(clock70HourTimerStarted) {                        clock70End()                    }                }            }        }    }    private fun executeOffDutyToNewStatus(currentEvent: String, newStatus: String) {        when (newStatus) {            AppConstants.START_DUTY_TITLE -> {                if (offDutyTimerStarted) {                    offDutyEnd()                }                if (isDutyStarted()) {                    if (!dutyTimerStarted) {                        startDuty(newStatus)                    }else{                        setEventState(currentEvent, newStatus)                    }                    if(!clock70HourTimerStarted) {                        clock70HourStart(newStatus)                    }                } else {                    startNewDuty(true)                    startDuty(newStatus)                    clock70HourStart(forceReset = true)                }            }            AppConstants.DRIVE_TITLE -> {                if (offDutyTimerStarted) {                    offDutyEnd()                }                if (!dutyTimerStarted) {                    startDuty(newStatus)                }                if (!driveTimerStarted) {                    driveStart(newStatus)                }                if(!clock70HourTimerStarted) {                    clock70HourStart(newStatus)                }            }            AppConstants.SLEEP_TITLE -> {                if (offDutyTimerStarted) {                    offDutyEnd()                }                if (isDutyStarted()) {                    if (!dutyTimerStarted) {                        startDuty(newStatus)                    }                    if(!clock70HourTimerStarted) {                        clock70HourStart(newStatus)                    }                } else {                    endDuty()                    sleepEnd(newStatus)                    driveEnd()                }                if (!sleepTimerStarted) {                    sleepStart(newStatus)                }            }            AppConstants.OFF_DUTY_TITLE -> {                dutyTimerStarted = false                driveTimerStarted = false                sleepTimerStarted = false                offDutyTimerStarted = true            }        }        if (offDutyTimerStarted) {            offDutyEnd()        }    }    private fun startDuty(newEvent: String, forceReset: Boolean = false) {        var remainingTimerTime = 0L        var event = PreferenceHelper().getString(requireContext(), AppConstants.PREF_PREVIOUS_EVENT)        if (!event.equals(newEvent, true) || forceReset) {            setEventState(event, newEvent)            pref.save(                requireContext(),                AppConstants.PREF_DUTY_START_TIME_STAMP,                System.currentTimeMillis().toString()            )            AppUtils.logger("=>Updating start time $event $newEvent")        }        var timeTemp =            pref.getString(requireContext(), AppConstants.PREF_DUTY_START_TIME_STAMP)                .toString()        var timeStampStartMill = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStartMill = timeTemp.toLong()        }        var remainingTimeFromPref = pref.getString(requireContext(), AppConstants.REMAINING_ON_DUTY).toString()        if (!remainingTimeFromPref?.isNullOrEmpty()!!) {            remainingTimerTime =                remainingTimeFromPref?.toLong()!! - (System.currentTimeMillis() - timeStampStartMill)        }        AppUtils.millisecondToTime("Duty Timer remaining Time ", remainingTimerTime)        if (remainingTimerTime > 0) {            startOnDutyTimer(remainingTimerTime)        }       // clock70HourStart(newEvent)    }    private fun endDuty() {        dutyTimerStarted = false        var timeTemp =            pref.getString(requireContext(), AppConstants.PREF_DUTY_START_TIME_STAMP)                .toString()        var timeStampStart = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStart = timeTemp.toLong()        }        var remainingPref = pref.getString(requireContext(), AppConstants.REMAINING_ON_DUTY)        val consumed = System.currentTimeMillis() - timeStampStart        val remaining = remainingPref?.toLong()!! - consumed        pref.save(requireContext(), AppConstants.REMAINING_ON_DUTY, remaining.toString())        if (this::onDutyTimer.isInitialized) {            onDutyTimer.cancel()        }        //clock70End()    }    private fun driveStart(newEvent: String, forceReset: Boolean = false) {        var remainingTimerTime = 0L        var event = pref.getString(requireContext(), AppConstants.PREF_CURRENT_EVENT)        if (!event.equals(newEvent, true) || forceReset) {            setEventState(event, newEvent)            pref.save(                requireContext(),                AppConstants.PREF_DRIVE_START_TIME_STAMP,                System.currentTimeMillis().toString()            )            AppUtils.logger("=>Updating drive time")        }        var timeTemp =            pref.getString(requireContext(), AppConstants.PREF_DRIVE_START_TIME_STAMP).toString()        var timeStampStartMill = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStartMill = timeTemp.toLong()        }        var remainingTimeFromPref = pref.getString(requireContext(), AppConstants.REMAINING_DRIVE)        remainingTimeFromPref?.let {        remainingTimerTime =            remainingTimeFromPref.toLong() - (System.currentTimeMillis() - timeStampStartMill)        }        AppUtils.millisecondToTime("Drive Timer remaining Time ", remainingTimerTime)        startDriveTimer(remainingTimerTime)    }    private fun driveEnd() {        driveTimerStarted = false        var timeTemp =            pref.getString(requireContext(), AppConstants.PREF_DRIVE_START_TIME_STAMP)                .toString()        var timeStampStart = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStart = timeTemp.toLong()        }        var remainingPref = pref.getString(requireContext(), AppConstants.REMAINING_DRIVE)        val consumed = System.currentTimeMillis() - timeStampStart        val remaining = remainingPref?.toLong()!! - consumed        pref.save(requireContext(), AppConstants.REMAINING_DRIVE, remaining.toString())        if (this::driveTimer.isInitialized) {            driveTimer.cancel()        }    }    private fun sleepStart(newEvent: String) {        var remainingTimerTime = 0L        var event = pref.getString(requireContext(), AppConstants.PREF_CURRENT_EVENT)        if (!event.equals(newEvent, true)) {            setEventState(event, newEvent)            pref.save(                requireContext(),                AppConstants.PREF_SLEEP_START_TIME_STAMP,                System.currentTimeMillis().toString()            )            //Save on duty remaining time to add in 70 hour clock when 10 hour complete            if(onDutyClockTime > 0){                pref.save(requireContext(), AppConstants.REMAINING_ON_DUTY_WHEN_SLEEP_START, onDutyClockTime.toString())            }            AppUtils.logger("=>Updating sleep time")            if (isSplitSleep()) {                calculateSplitSleep(false, newEvent)            }        }        var remainingTimeFromPref =            pref.getString(requireContext(), AppConstants.REMAINING_SLEEP).toString()        if (!remainingTimeFromPref.isNullOrEmpty() && remainingTimeFromPref.toLong() < 0) {            pref.save(requireContext(), AppConstants.REMAINING_SLEEP,                AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS.toString()            )            remainingTimeFromPref =                pref.getString(requireContext(), AppConstants.REMAINING_SLEEP).toString()        }        var timeTemp =            pref.getString(requireContext(), AppConstants.PREF_SLEEP_START_TIME_STAMP)                .toString()        var timeStampStartMill = 0L        var consumed = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStartMill = timeTemp.toLong()            consumed = System.currentTimeMillis() - timeStampStartMill        }        if (!remainingTimeFromPref.isNullOrEmpty()) {            remainingTimerTime = remainingTimeFromPref?.toLong()!! - consumed        }        AppUtils.millisecondToTime("Sleep Timer remaining Time ", remainingTimerTime)        startSleepTimer(remainingTimerTime)    }    private fun sleepEnd(newStatus: String) {        sleepTimerStarted = false        var timeTemp =            PreferenceHelper().getString(requireContext(), AppConstants.PREF_SLEEP_START_TIME_STAMP)                .toString()        var timeStampStart = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStart = timeTemp.toLong()        }        var remainingPref = pref.getString(requireContext(), AppConstants.REMAINING_SLEEP)        val consumed = System.currentTimeMillis() - timeStampStart        val remaining = remainingPref?.toLong()!! - consumed        if (isSplitSleep()) {            pref.save(requireContext(), AppConstants.REMAINING_SLEEP, remaining.toString())            calculateSplitSleep(true, newStatus)        } else            if (consumed < AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS) {                //Reset Sleep if sleep less then 10 hour                reloadSleep()            } else {                pref.save(requireContext(), AppConstants.REMAINING_SLEEP, remaining.toString())            }        if (::sleepTimer.isInitialized) {            sleepTimer.cancel()        }    }    private fun offDutyStart(newEvent: String) {        offDutyTimerStarted = true        var remainingTimerTime = 0L        var event = PreferenceHelper().getString(requireContext(), AppConstants.PREF_CURRENT_EVENT)        if (!event.equals(newEvent, true)) {            setEventState(event, newEvent)            pref.save(requireContext(),                AppConstants.PREF_OFF_DUTY_START_TIME_STAMP,                System.currentTimeMillis().toString()            )            AppUtils.logger("=>Updating Offduty time")        }        var timeTemp = pref.getString(requireContext(),AppConstants.PREF_OFF_DUTY_START_TIME_STAMP).toString()        var timeStampStartMill = 0L        var consumed = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStartMill = timeTemp.toLong()            consumed = System.currentTimeMillis() - timeStampStartMill        }        var remainingTimeFromPref =            pref.getString(requireContext(), "REMAINING_OFF_DUTY")        if (!remainingTimeFromPref.isNullOrEmpty()) {            remainingTimerTime = remainingTimeFromPref?.toLong()!! - consumed        }        AppUtils.millisecondToTime("OffDuty Timer remaining Time ", remainingTimerTime)        //start70HourTimer(remainingTimerTime)    }    private fun offDutyEnd() {        offDutyTimerStarted = false        var timeTemp = pref.getString(requireContext(),            AppConstants.PREF_OFF_DUTY_START_TIME_STAMP).toString()        var remainingPref = pref.getString(requireContext(), "REMAINING_OFF_DUTY")        var timeStampStart = 0L        var consumed = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStart = timeTemp.toLong()            consumed = System.currentTimeMillis() - timeStampStart        }        if (!remainingPref.isNullOrEmpty()) {            val remaining = remainingPref?.toLong()!! - consumed            pref.save(requireContext(), "REMAINING_OFF_DUTY", remaining.toString())        }//        if (::on70HourTimer.isInitialized) {//            on70HourTimer.cancel()//        }    }    private fun startOnDutyTimer(time: Long) {        if (this::onDutyTimer.isInitialized) {            onDutyTimer.cancel()        }        onDutyTimer = object : CountDownTimer(time, 1000) {            override fun onTick(millisUntilFinished: Long) {                dutyTimerStarted = true                onDutyClockTime = millisUntilFinished                val hours: Int = (millisUntilFinished / (60 * 60 * 1000)).toInt()                val minutes: Int = ((millisUntilFinished / (60 * 1000)) % 60).toInt()                val sec: Int = ((millisUntilFinished / 1000) % 60).toInt()                AppUtils.logger("Step: Drive=>$hours:$minutes:$sec\"")                var dutyHour = String.format("%02d:%02d:%02d", hours, minutes, sec)                CoroutineScope(Dispatchers.Main).launch {                    binding.onDutyTimeLeft.text = dutyHour                }            }            override fun onFinish() {                AppUtils.logger("Step: onFinish CountDownTimer")                var dutyHour = String.format("%02d:%02d", 0, 0)                CoroutineScope(Dispatchers.Main).launch {                    binding.onDutyTimeLeft.text = dutyHour                    makeToast("ON Duty Violation")                    createViolation(AppConstants.ON_DUTY_ND_VIOLATION)                }            }        }        onDutyTimer.start()    }    private fun startDriveTimer(time: Long) {        if (this::driveTimer.isInitialized) {            driveTimer.cancel()        }        driveTimer = object : CountDownTimer(time, 1000) {            override fun onTick(millisUntilFinished: Long) {                driveTimerStarted = true                driveClockTime = millisUntilFinished                val hours: Int = (millisUntilFinished / (60 * 60 * 1000)).toInt()                val minutes: Int = ((millisUntilFinished / (60 * 1000)) % 60).toInt()                val sec: Int = ((millisUntilFinished / 1000) % 60).toInt()                //AppUtils.logger("Step: Drive Timer$hours:$minutes:$sec\"")                var dutyHour = String.format("%02d:%02d:%02d", hours, minutes, sec)                CoroutineScope(Dispatchers.Main).launch {                    binding.driveTimer.text = dutyHour                    //AppUtils.logger("===> $dutyHour")                }            }            override fun onFinish() {                AppUtils.logger("Step: onFinish CountDownTimer")                var dutyHour = String.format("%02d:%02d", 0, 0)                CoroutineScope(Dispatchers.Main).launch {                    binding.driveTimer.text = dutyHour                    makeToast("Drive Violation")                    createViolation(AppConstants.DRIVE_VIOLATION)                }            }        }        driveTimer.start()    }    private fun startSleepTimer(time: Long) {        if (this::sleepTimer.isInitialized) {            sleepTimer.cancel()        }        sleepTimer = object : CountDownTimer(time, 1000) {            override fun onTick(millisUntilFinished: Long) {                sleepTimerStarted = true                val hours: Int = (millisUntilFinished / (60 * 60 * 1000)).toInt()                val minutes: Int = ((millisUntilFinished / (60 * 1000)) % 60).toInt()                val sec: Int = ((millisUntilFinished / 1000) % 60).toInt()                //AppUtils.logger("Step: Sleep Timer$hours:$minutes:$sec\"")                var dutyHour = String.format("%02d:%02d:%02d", hours, minutes, sec)                CoroutineScope(Dispatchers.Main).launch {                    binding.sleepTimer.text = dutyHour                }            }            override fun onFinish() {                AppUtils.logger("Step: onFinish CountDownTimer")                var dutyHour = String.format("%02d:%02d:%02d", 0, 0, 0)                CoroutineScope(Dispatchers.Main).launch {                    binding.sleepTimer.text = dutyHour                }                if(calculateOnce /*&& !isSplitEnable()*/) {                    calculateNonSplitSleepTime()                }            }        }        sleepTimer.start()    }    private fun clock70HourStart(newEvent: String = "", forceReset: Boolean = false) {        var remainingTimerTime = 0L        var event = PreferenceHelper().getString(requireContext(), AppConstants.PREF_CURRENT_EVENT)        if (!event.equals(newEvent, true) || forceReset) {            //setEventState(current, newEvent)            pref.save(                requireContext(),                AppConstants.PREF_70_HOUR_CLOCK_TIME_STAMP,                System.currentTimeMillis().toString()            )            AppUtils.logger("=>Updating start time $event $newEvent")        }        var timeTemp = pref.getString(requireContext(), AppConstants.PREF_70_HOUR_CLOCK_TIME_STAMP).toString()        var timeStampStartMill = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStartMill = timeTemp.toLong()        }        var remainingTimeFromPref = pref.getString(requireContext(), AppConstants.REMAINING_70_HOUR).toString()        if (!remainingTimeFromPref?.isNullOrEmpty()!!) {            remainingTimerTime =                remainingTimeFromPref?.toLong()!! - (System.currentTimeMillis() - timeStampStartMill)        }        AppUtils.millisecondToTime("Duty Timer remaining Time ", remainingTimerTime)        if (remainingTimerTime > 0) {            startClock70HourTimer(remainingTimerTime)        }    }    private fun clock70End() {        clock70HourTimerStarted = false        var timeTemp =            pref.getString(requireContext(), AppConstants.PREF_70_HOUR_CLOCK_TIME_STAMP)                .toString()        var timeStampStart = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStart = timeTemp.toLong()        }        var remainingPref = pref.getString(requireContext(), AppConstants.REMAINING_70_HOUR)        val consumed = System.currentTimeMillis() - timeStampStart        val remaining = remainingPref?.toLong()!! - consumed        pref.save(requireContext(), AppConstants.REMAINING_70_HOUR, remaining.toString())        if (this::on70HourTimer.isInitialized) {            on70HourTimer.cancel()        }    }    private fun startClock70HourTimer(time: Long) {        if (this::on70HourTimer.isInitialized) {            on70HourTimer.cancel()        }        on70HourTimer = object : CountDownTimer(time, 1000) {            override fun onTick(millisUntilFinished: Long) {                clock70HourTimerStarted = true                clock70HourTime = millisUntilFinished                val hours: Int = (millisUntilFinished / (60 * 60 * 1000)).toInt()                val minutes: Int = ((millisUntilFinished / (60 * 1000)) % 60).toInt()                val sec: Int = ((millisUntilFinished / 1000) % 60).toInt()                //AppUtils.logger("Step: OnDuty Timer$hours:$minutes:$sec\"")                var dutyHour = String.format("%02d:%02d:%02d", hours, minutes, sec)                CoroutineScope(Dispatchers.Main).launch {                    delay(200)                    binding.timer70Hour.text = dutyHour                }            }            override fun onFinish() {                clock70HourTimerStarted = false                //Start Time Stamp for                //Clock 70 Completed                pref.save(requireContext(), AppConstants.CLOCK_70_COMPLETED, true)                dialog.show {                    title(text = getString(R.string.dialog_title_Msg))                    message(text = getString(R.string.duty_rest_clock_70))                    positiveButton(text = getString(R.string.ok)) {                        dutyTimerStarted = false                        reloadData()                        setZeroClocksTime()                        dialog.cancel()                    }                }                dialog.cancelOnTouchOutside(false)                    AppUtils.logger("Step: onFinish CountDownTimer")                var dutyHour = String.format("%02d:%02d", 0, 0)                CoroutineScope(Dispatchers.Main).launch {                    binding.timer70Hour.text = dutyHour                }            }        }        on70HourTimer.start()    }    /**     * @return Duty has been started or Not     */    private fun isDutyStarted(): Boolean {        activity?.let {            return pref.getBoolean(requireContext(), AppConstants.DUTY_STARTED, false)        }        return false    }    /**     * Start New Duty flag     */    private fun startNewDuty(start: Boolean) {        pref.save(requireContext(), AppConstants.DUTY_STARTED, start)        if (start) {            val remaining = timeFromPref(AppConstants.REMAINING_70_HOUR)            if (remaining > 0 && isClock70Completed()) {                if (isClock34Completed()) {                    makeToast("Go off Duty at least for 34 hours")                } else {                    if(!clock70HourTimerStarted) {                        pref.save(requireContext(), AppConstants.PREF_70_HOUR_CLOCK_TIME_STAMP, "")                        pref.save(requireContext(), AppConstants.REMAINING_70_HOUR,                            AppConstants.TOTAL_70_HOURS_MILLI_SECONDS.toString()                        )                    }                }            }        }    }    /**     * Return clock 70 Status weather is running or not     */    private fun isClock70Completed(): Boolean {        activity?.let {            return pref.getBoolean(requireContext(), AppConstants.CLOCK_70_COMPLETED, false)        }        return false    }    /**     * Return clock 34 Status weather is started or not     */    private fun isClock34Started(): Boolean {        activity?.let {            return pref.getBoolean(requireContext(), AppConstants.CLOCK_34_STARTED, false)        }        return false    }    /**     * Return clock 34 Status weather is started or not     */    private fun isClock34Completed(): Boolean {        activity?.let {            var duration = 0L            val timeStamp = timeFromPref(AppConstants.CLOCK_34_START_TIME_STAMP)            if(timeStamp > 0){                duration = System.currentTimeMillis() - timeStamp            }else{                duration = 0            }            if(duration > AppConstants.CLOCK_34_HOUR_TIME){                pref.save(requireContext(), AppConstants.CLOCK_70_COMPLETED, false)                pref.save(requireContext(), AppConstants.CLOCK_34_STARTED, false)                pref.save(requireContext(), AppConstants.CLOCK_34_START_TIME_STAMP,"")//                reloadData(startDuty = true)                //stepDecider(previousEvent(), currentEvent())                makeToast("You Are eligible to start new Duty...")                return true            }        }        return false    }    /**     * Start clock 34     *     */    private fun startClock34() {        activity?.let {            pref.save(requireContext(), AppConstants.CLOCK_34_STARTED, true)            pref.save(requireContext(), AppConstants.CLOCK_34_START_TIME_STAMP,                System.currentTimeMillis().toString())        }    }    private fun isDayEightCompleted() {        var timeTemp =  pref.getString(requireContext(), AppConstants.DAY_EIGHT_START_TIME_STAMP).toString()        var timeStampStart = 0L        if (!timeTemp.isNullOrEmpty()) {            timeStampStart = timeTemp.toLong()        }        val timeConsumed = System.currentTimeMillis() - timeStampStart        if(timeConsumed > AppConstants.TOTAL_EIGHT_DAY_TO_MILLI_SECONDS){        }    }    private fun dayEightStarted(): Boolean {        activity?.let {            return pref.getBoolean(requireContext(), AppConstants.DAY_EIGHT_STARTED, false)        }        return false    }    private fun resetDayEight(reset: Boolean) {        pref.save(requireContext(), AppConstants.DAY_EIGHT_STARTED, reset)        pref.save(requireContext(), AppConstants.DAY_EIGHT_START_TIME_STAMP, System.currentTimeMillis().toString())    }    /**     * Reload the Duty Clocks timings     */    fun reloadData(startDuty: Boolean = false, with70HourClock: Boolean = false) {            startNewDuty(startDuty)            pref.save(                requireContext(),                AppConstants.REMAINING_SLEEP,                AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS.toString()            )            pref.save(                requireContext(),                AppConstants.REMAINING_ON_DUTY,                AppConstants.TOTAL_DUTY_HOURS_MILLI_SECONDS.toString()            )            pref.save(                requireContext(),                AppConstants.REMAINING_DRIVE,                AppConstants.TOTAL_DRIVE_HOURS_MILL_SECONDS.toString()            )            pref.save(                requireContext(),                AppConstants.REMAINING_OFF_DUTY,                AppConstants.TOTAL_SLEEP_HOURS_MILL_SECONDS.toString()            )            if(with70HourClock){                pref.save(                    requireContext(),                    AppConstants.REMAINING_70_HOUR,                    AppConstants.TOTAL_70_HOURS_MILLI_SECONDS.toString()                )            }            pref.save(                requireContext(),                AppConstants.PREF_OFF_DUTY_START_TIME_STAMP,                ""            )            pref.save(                requireContext(),                AppConstants.PREF_IS_FIRST_SPLIT_SLEEP,                false            )            pref.save(                requireContext(),                AppConstants.PREF_IS_SECOND_SPLIT_SLEEP,                false            )            pref.save(requireContext(), AppConstants.PREF_SLEEP_START_TIME_STAMP, "")            saveSplitSleepInPref(AppConstants.NO_SPLIT)        if (::onDutyTimer.isInitialized)            onDutyTimer.cancel()        if (::driveTimer.isInitialized)            driveTimer.cancel()        if (::sleepTimer.isInitialized)            sleepTimer.cancel()        if(::on70HourTimer.isInitialized)            on70HourTimer.cancel()    }    private fun setZeroClocksTime() {        val sleepHours: Int = (0/ (60 * 60 * 1000))        val sleepMinutes: Int = ((0 / (60 * 1000)) % 60)        val sleepTime = String.format("%02d:%02d", sleepHours, sleepMinutes)        val driveHours: Int = (0 / (60 * 60 * 1000))        val driveMinutes: Int = ((0 / (60 * 1000)) % 60)        var driveHour = String.format("%02d:%02d", driveHours, driveMinutes)        val dutyHours: Int = (0 / (60 * 60 * 1000))        val dutyMinutes: Int = ((0 / (60 * 1000)) % 60)        var onDutyHour = String.format("%02d:%02d", dutyHours, dutyMinutes)        binding.sleepTimer.text = sleepTime        binding.onDutyTimeLeft.text = onDutyHour        binding.driveTimer.text = driveHour    }    override fun onDestroyView() {        if (::onDutyTimer.isInitialized)            onDutyTimer.cancel()        if (::driveTimer.isInitialized)            driveTimer.cancel()        if (::sleepTimer.isInitialized)            sleepTimer.cancel()        super.onDestroyView()    }    private fun showStartDutyDialog() {        CoroutineScope(Dispatchers.Main).launch {            dialog.show {                title(text = getString(R.string.dialog_title_Msg))                message(text = getString(R.string.duty_rest))                positiveButton(text = getString(R.string.ok)) {                }            }        }    }    private fun timeFromPref(prefKey: String): Long{        var time = pref.getString(requireContext(), prefKey).toString()        var timeToReturn = 0L        if (time.isNotEmpty()) {            timeToReturn = time.toLong()        }        return timeToReturn    }    /**     * Get the time form Pref and add time to this     */    private fun timeUpdate70HourClockToPref(prefKey: String, updateTimeInMilliseconds: Long, timeReversal: Boolean){        try {            var time = pref.getString(requireContext(), prefKey).toString()            var timeToReturn = 0L            if (time.isNotEmpty()) {                timeToReturn = time.toLong()            }            AppUtils.millisecondToTime("clock70HourTime Remaining time before:- ", clock70HourTime)            AppUtils.millisecondToTime("updateTimeInMilliseconds:- ", updateTimeInMilliseconds)            var update = 0L            if(clock70HourTimerStarted){                //update = clock70HourTime                AppUtils.millisecondToTime("Clock 70 Before update:- :- ", updateTimeInMilliseconds)                if(timeReversal){                    update = clock70HourTime - updateTimeInMilliseconds                }else{                    update = clock70HourTime + updateTimeInMilliseconds                }            }else{                if(timeReversal){                    update = timeToReturn - updateTimeInMilliseconds                }else{                    update =  timeToReturn + updateTimeInMilliseconds                }            }            Log.d("TAG: clock", clock70HourTime.toString())            Log.d("TAG: add", updateTimeInMilliseconds.toString())            Log.d("TAG: Total", ((clock70HourTime + updateTimeInMilliseconds.toLong()).toString()))            AppUtils.millisecondToTime("Clock 70 after update:- ", update)            pref.save(requireContext(), prefKey, update.toString())            Log.d("TAG: Update", update.toString())            //AppUtils.millisecondToTime("updated 70 Hour:- ", update)        }catch (e: Exception){            e.printStackTrace()        }    }}